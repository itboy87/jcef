/**
 * Autogenerated by Thrift Compiler (0.19.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Server.h"

namespace thrift_codegen {


Server_connect_args::~Server_connect_args() noexcept {
}


uint32_t Server_connect_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->backwardConnectionPipe);
          this->__isset.backwardConnectionPipe = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isMaster);
          this->__isset.isMaster = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_connect_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_connect_args");

  xfer += oprot->writeFieldBegin("backwardConnectionPipe", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->backwardConnectionPipe);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isMaster", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->isMaster);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_connect_pargs::~Server_connect_pargs() noexcept {
}


uint32_t Server_connect_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_connect_pargs");

  xfer += oprot->writeFieldBegin("backwardConnectionPipe", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->backwardConnectionPipe)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isMaster", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->isMaster)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_connect_result::~Server_connect_result() noexcept {
}


uint32_t Server_connect_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_connect_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_connect_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_connect_presult::~Server_connect_presult() noexcept {
}


uint32_t Server_connect_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_connectTcp_args::~Server_connectTcp_args() noexcept {
}


uint32_t Server_connectTcp_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->backwardConnectionPort);
          this->__isset.backwardConnectionPort = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isMaster);
          this->__isset.isMaster = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_connectTcp_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_connectTcp_args");

  xfer += oprot->writeFieldBegin("backwardConnectionPort", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->backwardConnectionPort);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isMaster", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->isMaster);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_connectTcp_pargs::~Server_connectTcp_pargs() noexcept {
}


uint32_t Server_connectTcp_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_connectTcp_pargs");

  xfer += oprot->writeFieldBegin("backwardConnectionPort", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->backwardConnectionPort)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isMaster", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->isMaster)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_connectTcp_result::~Server_connectTcp_result() noexcept {
}


uint32_t Server_connectTcp_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_connectTcp_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_connectTcp_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_connectTcp_presult::~Server_connectTcp_presult() noexcept {
}


uint32_t Server_connectTcp_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_log_args::~Server_log_args() noexcept {
}


uint32_t Server_log_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_log_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_log_args");

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_log_pargs::~Server_log_pargs() noexcept {
}


uint32_t Server_log_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_log_pargs");

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->msg)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_echo_args::~Server_echo_args() noexcept {
}


uint32_t Server_echo_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_echo_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_echo_args");

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_echo_pargs::~Server_echo_pargs() noexcept {
}


uint32_t Server_echo_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_echo_pargs");

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->msg)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_echo_result::~Server_echo_result() noexcept {
}


uint32_t Server_echo_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_echo_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_echo_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_echo_presult::~Server_echo_presult() noexcept {
}


uint32_t Server_echo_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_version_args::~Server_version_args() noexcept {
}


uint32_t Server_version_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_version_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_version_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_version_pargs::~Server_version_pargs() noexcept {
}


uint32_t Server_version_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_version_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_version_result::~Server_version_result() noexcept {
}


uint32_t Server_version_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_version_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_version_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_version_presult::~Server_version_presult() noexcept {
}


uint32_t Server_version_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_state_args::~Server_state_args() noexcept {
}


uint32_t Server_state_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_state_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_state_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_state_pargs::~Server_state_pargs() noexcept {
}


uint32_t Server_state_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_state_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_state_result::~Server_state_result() noexcept {
}


uint32_t Server_state_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_state_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_state_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_state_presult::~Server_state_presult() noexcept {
}


uint32_t Server_state_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_stop_args::~Server_stop_args() noexcept {
}


uint32_t Server_stop_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_stop_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_stop_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_stop_pargs::~Server_stop_pargs() noexcept {
}


uint32_t Server_stop_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_stop_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_Create_args::~Server_Browser_Create_args() noexcept {
}


uint32_t Server_Browser_Create_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cid);
          this->__isset.cid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->handlersMask);
          this->__isset.handlersMask = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->requestContextHandler.read(iprot);
          this->__isset.requestContextHandler = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_Create_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_Create_args");

  xfer += oprot->writeFieldBegin("cid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->cid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("handlersMask", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->handlersMask);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("requestContextHandler", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->requestContextHandler.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_Create_pargs::~Server_Browser_Create_pargs() noexcept {
}


uint32_t Server_Browser_Create_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_Create_pargs");

  xfer += oprot->writeFieldBegin("cid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->cid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("handlersMask", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->handlersMask)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("requestContextHandler", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->requestContextHandler)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_Create_result::~Server_Browser_Create_result() noexcept {
}


uint32_t Server_Browser_Create_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_Create_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Browser_Create_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_Create_presult::~Server_Browser_Create_presult() noexcept {
}


uint32_t Server_Browser_Create_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Browser_StartNativeCreation_args::~Server_Browser_StartNativeCreation_args() noexcept {
}


uint32_t Server_Browser_StartNativeCreation_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          this->__isset.url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_StartNativeCreation_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_StartNativeCreation_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_StartNativeCreation_pargs::~Server_Browser_StartNativeCreation_pargs() noexcept {
}


uint32_t Server_Browser_StartNativeCreation_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_StartNativeCreation_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->url)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_Close_args::~Server_Browser_Close_args() noexcept {
}


uint32_t Server_Browser_Close_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_Close_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_Close_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_Close_pargs::~Server_Browser_Close_pargs() noexcept {
}


uint32_t Server_Browser_Close_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_Close_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_Reload_args::~Server_Browser_Reload_args() noexcept {
}


uint32_t Server_Browser_Reload_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_Reload_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_Reload_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_Reload_pargs::~Server_Browser_Reload_pargs() noexcept {
}


uint32_t Server_Browser_Reload_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_Reload_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_ReloadIgnoreCache_args::~Server_Browser_ReloadIgnoreCache_args() noexcept {
}


uint32_t Server_Browser_ReloadIgnoreCache_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_ReloadIgnoreCache_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_ReloadIgnoreCache_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_ReloadIgnoreCache_pargs::~Server_Browser_ReloadIgnoreCache_pargs() noexcept {
}


uint32_t Server_Browser_ReloadIgnoreCache_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_ReloadIgnoreCache_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_LoadURL_args::~Server_Browser_LoadURL_args() noexcept {
}


uint32_t Server_Browser_LoadURL_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          this->__isset.url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_LoadURL_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_LoadURL_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_LoadURL_pargs::~Server_Browser_LoadURL_pargs() noexcept {
}


uint32_t Server_Browser_LoadURL_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_LoadURL_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->url)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_LoadRequest_args::~Server_Browser_LoadRequest_args() noexcept {
}


uint32_t Server_Browser_LoadRequest_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_LoadRequest_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_LoadRequest_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_LoadRequest_pargs::~Server_Browser_LoadRequest_pargs() noexcept {
}


uint32_t Server_Browser_LoadRequest_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_LoadRequest_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->request)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetURL_args::~Server_Browser_GetURL_args() noexcept {
}


uint32_t Server_Browser_GetURL_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_GetURL_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_GetURL_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetURL_pargs::~Server_Browser_GetURL_pargs() noexcept {
}


uint32_t Server_Browser_GetURL_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_GetURL_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetURL_result::~Server_Browser_GetURL_result() noexcept {
}


uint32_t Server_Browser_GetURL_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_GetURL_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Browser_GetURL_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetURL_presult::~Server_Browser_GetURL_presult() noexcept {
}


uint32_t Server_Browser_GetURL_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Browser_ExecuteJavaScript_args::~Server_Browser_ExecuteJavaScript_args() noexcept {
}


uint32_t Server_Browser_ExecuteJavaScript_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          this->__isset.url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->line);
          this->__isset.line = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_ExecuteJavaScript_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_ExecuteJavaScript_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("line", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->line);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_ExecuteJavaScript_pargs::~Server_Browser_ExecuteJavaScript_pargs() noexcept {
}


uint32_t Server_Browser_ExecuteJavaScript_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_ExecuteJavaScript_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->code)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->url)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("line", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->line)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_WasResized_args::~Server_Browser_WasResized_args() noexcept {
}


uint32_t Server_Browser_WasResized_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_WasResized_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_WasResized_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_WasResized_pargs::~Server_Browser_WasResized_pargs() noexcept {
}


uint32_t Server_Browser_WasResized_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_WasResized_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_NotifyScreenInfoChanged_args::~Server_Browser_NotifyScreenInfoChanged_args() noexcept {
}


uint32_t Server_Browser_NotifyScreenInfoChanged_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_NotifyScreenInfoChanged_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_NotifyScreenInfoChanged_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_NotifyScreenInfoChanged_pargs::~Server_Browser_NotifyScreenInfoChanged_pargs() noexcept {
}


uint32_t Server_Browser_NotifyScreenInfoChanged_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_NotifyScreenInfoChanged_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_SendKeyEvent_args::~Server_Browser_SendKeyEvent_args() noexcept {
}


uint32_t Server_Browser_SendKeyEvent_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->event_type);
          this->__isset.event_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->modifiers);
          this->__isset.modifiers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->key_char);
          this->__isset.key_char = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->scanCode);
          this->__isset.scanCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->key_code);
          this->__isset.key_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_SendKeyEvent_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_SendKeyEvent_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("event_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->event_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("modifiers", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->modifiers);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_char", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->key_char);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scanCode", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->scanCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_code", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->key_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_SendKeyEvent_pargs::~Server_Browser_SendKeyEvent_pargs() noexcept {
}


uint32_t Server_Browser_SendKeyEvent_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_SendKeyEvent_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("event_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->event_type)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("modifiers", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->modifiers)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_char", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16((*(this->key_char)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scanCode", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64((*(this->scanCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_code", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((*(this->key_code)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_SendMouseEvent_args::~Server_Browser_SendMouseEvent_args() noexcept {
}


uint32_t Server_Browser_SendMouseEvent_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->event_type);
          this->__isset.event_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->modifiers);
          this->__isset.modifiers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->click_count);
          this->__isset.click_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->button);
          this->__isset.button = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_SendMouseEvent_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_SendMouseEvent_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("event_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->event_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("modifiers", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->modifiers);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("click_count", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->click_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("button", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->button);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_SendMouseEvent_pargs::~Server_Browser_SendMouseEvent_pargs() noexcept {
}


uint32_t Server_Browser_SendMouseEvent_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_SendMouseEvent_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("event_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->event_type)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->x)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->y)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("modifiers", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((*(this->modifiers)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("click_count", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((*(this->click_count)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("button", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((*(this->button)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_SendMouseWheelEvent_args::~Server_Browser_SendMouseWheelEvent_args() noexcept {
}


uint32_t Server_Browser_SendMouseWheelEvent_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->scroll_type);
          this->__isset.scroll_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->modifiers);
          this->__isset.modifiers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->delta);
          this->__isset.delta = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->units_to_scroll);
          this->__isset.units_to_scroll = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_SendMouseWheelEvent_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_SendMouseWheelEvent_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scroll_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->scroll_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("modifiers", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->modifiers);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delta", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->delta);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("units_to_scroll", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->units_to_scroll);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_SendMouseWheelEvent_pargs::~Server_Browser_SendMouseWheelEvent_pargs() noexcept {
}


uint32_t Server_Browser_SendMouseWheelEvent_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_SendMouseWheelEvent_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scroll_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->scroll_type)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->x)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->y)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("modifiers", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((*(this->modifiers)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delta", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((*(this->delta)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("units_to_scroll", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((*(this->units_to_scroll)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_CanGoForward_args::~Server_Browser_CanGoForward_args() noexcept {
}


uint32_t Server_Browser_CanGoForward_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_CanGoForward_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_CanGoForward_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_CanGoForward_pargs::~Server_Browser_CanGoForward_pargs() noexcept {
}


uint32_t Server_Browser_CanGoForward_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_CanGoForward_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_CanGoForward_result::~Server_Browser_CanGoForward_result() noexcept {
}


uint32_t Server_Browser_CanGoForward_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_CanGoForward_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Browser_CanGoForward_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_CanGoForward_presult::~Server_Browser_CanGoForward_presult() noexcept {
}


uint32_t Server_Browser_CanGoForward_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Browser_CanGoBack_args::~Server_Browser_CanGoBack_args() noexcept {
}


uint32_t Server_Browser_CanGoBack_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_CanGoBack_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_CanGoBack_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_CanGoBack_pargs::~Server_Browser_CanGoBack_pargs() noexcept {
}


uint32_t Server_Browser_CanGoBack_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_CanGoBack_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_CanGoBack_result::~Server_Browser_CanGoBack_result() noexcept {
}


uint32_t Server_Browser_CanGoBack_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_CanGoBack_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Browser_CanGoBack_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_CanGoBack_presult::~Server_Browser_CanGoBack_presult() noexcept {
}


uint32_t Server_Browser_CanGoBack_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Browser_GoBack_args::~Server_Browser_GoBack_args() noexcept {
}


uint32_t Server_Browser_GoBack_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_GoBack_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_GoBack_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GoBack_pargs::~Server_Browser_GoBack_pargs() noexcept {
}


uint32_t Server_Browser_GoBack_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_GoBack_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GoForward_args::~Server_Browser_GoForward_args() noexcept {
}


uint32_t Server_Browser_GoForward_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_GoForward_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_GoForward_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GoForward_pargs::~Server_Browser_GoForward_pargs() noexcept {
}


uint32_t Server_Browser_GoForward_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_GoForward_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_IsLoading_args::~Server_Browser_IsLoading_args() noexcept {
}


uint32_t Server_Browser_IsLoading_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_IsLoading_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_IsLoading_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_IsLoading_pargs::~Server_Browser_IsLoading_pargs() noexcept {
}


uint32_t Server_Browser_IsLoading_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_IsLoading_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_IsLoading_result::~Server_Browser_IsLoading_result() noexcept {
}


uint32_t Server_Browser_IsLoading_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_IsLoading_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Browser_IsLoading_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_IsLoading_presult::~Server_Browser_IsLoading_presult() noexcept {
}


uint32_t Server_Browser_IsLoading_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Browser_StopLoad_args::~Server_Browser_StopLoad_args() noexcept {
}


uint32_t Server_Browser_StopLoad_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_StopLoad_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_StopLoad_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_StopLoad_pargs::~Server_Browser_StopLoad_pargs() noexcept {
}


uint32_t Server_Browser_StopLoad_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_StopLoad_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetMainFrame_args::~Server_Browser_GetMainFrame_args() noexcept {
}


uint32_t Server_Browser_GetMainFrame_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_GetMainFrame_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_GetMainFrame_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetMainFrame_pargs::~Server_Browser_GetMainFrame_pargs() noexcept {
}


uint32_t Server_Browser_GetMainFrame_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_GetMainFrame_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetMainFrame_result::~Server_Browser_GetMainFrame_result() noexcept {
}


uint32_t Server_Browser_GetMainFrame_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_GetMainFrame_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Browser_GetMainFrame_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetMainFrame_presult::~Server_Browser_GetMainFrame_presult() noexcept {
}


uint32_t Server_Browser_GetMainFrame_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Browser_GetFocusedFrame_args::~Server_Browser_GetFocusedFrame_args() noexcept {
}


uint32_t Server_Browser_GetFocusedFrame_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_GetFocusedFrame_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_GetFocusedFrame_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetFocusedFrame_pargs::~Server_Browser_GetFocusedFrame_pargs() noexcept {
}


uint32_t Server_Browser_GetFocusedFrame_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_GetFocusedFrame_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetFocusedFrame_result::~Server_Browser_GetFocusedFrame_result() noexcept {
}


uint32_t Server_Browser_GetFocusedFrame_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_GetFocusedFrame_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Browser_GetFocusedFrame_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetFocusedFrame_presult::~Server_Browser_GetFocusedFrame_presult() noexcept {
}


uint32_t Server_Browser_GetFocusedFrame_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Browser_GetFrameByIdentifier_args::~Server_Browser_GetFrameByIdentifier_args() noexcept {
}


uint32_t Server_Browser_GetFrameByIdentifier_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->identifier);
          this->__isset.identifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_GetFrameByIdentifier_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_GetFrameByIdentifier_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("identifier", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->identifier);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetFrameByIdentifier_pargs::~Server_Browser_GetFrameByIdentifier_pargs() noexcept {
}


uint32_t Server_Browser_GetFrameByIdentifier_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_GetFrameByIdentifier_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("identifier", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->identifier)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetFrameByIdentifier_result::~Server_Browser_GetFrameByIdentifier_result() noexcept {
}


uint32_t Server_Browser_GetFrameByIdentifier_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_GetFrameByIdentifier_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Browser_GetFrameByIdentifier_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetFrameByIdentifier_presult::~Server_Browser_GetFrameByIdentifier_presult() noexcept {
}


uint32_t Server_Browser_GetFrameByIdentifier_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Browser_GetFrameByName_args::~Server_Browser_GetFrameByName_args() noexcept {
}


uint32_t Server_Browser_GetFrameByName_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_GetFrameByName_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_GetFrameByName_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetFrameByName_pargs::~Server_Browser_GetFrameByName_pargs() noexcept {
}


uint32_t Server_Browser_GetFrameByName_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_GetFrameByName_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->name)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetFrameByName_result::~Server_Browser_GetFrameByName_result() noexcept {
}


uint32_t Server_Browser_GetFrameByName_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_GetFrameByName_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Browser_GetFrameByName_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetFrameByName_presult::~Server_Browser_GetFrameByName_presult() noexcept {
}


uint32_t Server_Browser_GetFrameByName_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Browser_GetFrameCount_args::~Server_Browser_GetFrameCount_args() noexcept {
}


uint32_t Server_Browser_GetFrameCount_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_GetFrameCount_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_GetFrameCount_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetFrameCount_pargs::~Server_Browser_GetFrameCount_pargs() noexcept {
}


uint32_t Server_Browser_GetFrameCount_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_GetFrameCount_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetFrameCount_result::~Server_Browser_GetFrameCount_result() noexcept {
}


uint32_t Server_Browser_GetFrameCount_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_GetFrameCount_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Browser_GetFrameCount_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetFrameCount_presult::~Server_Browser_GetFrameCount_presult() noexcept {
}


uint32_t Server_Browser_GetFrameCount_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Browser_GetFrameIdentifiers_args::~Server_Browser_GetFrameIdentifiers_args() noexcept {
}


uint32_t Server_Browser_GetFrameIdentifiers_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_GetFrameIdentifiers_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_GetFrameIdentifiers_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetFrameIdentifiers_pargs::~Server_Browser_GetFrameIdentifiers_pargs() noexcept {
}


uint32_t Server_Browser_GetFrameIdentifiers_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_GetFrameIdentifiers_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetFrameIdentifiers_result::~Server_Browser_GetFrameIdentifiers_result() noexcept {
}


uint32_t Server_Browser_GetFrameIdentifiers_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->success.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readString(this->success[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_GetFrameIdentifiers_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Browser_GetFrameIdentifiers_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::vector<std::string> ::const_iterator _iter5;
      for (_iter5 = this->success.begin(); _iter5 != this->success.end(); ++_iter5)
      {
        xfer += oprot->writeString((*_iter5));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetFrameIdentifiers_presult::~Server_Browser_GetFrameIdentifiers_presult() noexcept {
}


uint32_t Server_Browser_GetFrameIdentifiers_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            (*(this->success)).resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += iprot->readString((*(this->success))[_i10]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Browser_GetFrameNames_args::~Server_Browser_GetFrameNames_args() noexcept {
}


uint32_t Server_Browser_GetFrameNames_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_GetFrameNames_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_GetFrameNames_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetFrameNames_pargs::~Server_Browser_GetFrameNames_pargs() noexcept {
}


uint32_t Server_Browser_GetFrameNames_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_GetFrameNames_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetFrameNames_result::~Server_Browser_GetFrameNames_result() noexcept {
}


uint32_t Server_Browser_GetFrameNames_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size11;
            ::apache::thrift::protocol::TType _etype14;
            xfer += iprot->readListBegin(_etype14, _size11);
            this->success.resize(_size11);
            uint32_t _i15;
            for (_i15 = 0; _i15 < _size11; ++_i15)
            {
              xfer += iprot->readString(this->success[_i15]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_GetFrameNames_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Browser_GetFrameNames_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::vector<std::string> ::const_iterator _iter16;
      for (_iter16 = this->success.begin(); _iter16 != this->success.end(); ++_iter16)
      {
        xfer += oprot->writeString((*_iter16));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetFrameNames_presult::~Server_Browser_GetFrameNames_presult() noexcept {
}


uint32_t Server_Browser_GetFrameNames_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size17;
            ::apache::thrift::protocol::TType _etype20;
            xfer += iprot->readListBegin(_etype20, _size17);
            (*(this->success)).resize(_size17);
            uint32_t _i21;
            for (_i21 = 0; _i21 < _size17; ++_i21)
            {
              xfer += iprot->readString((*(this->success))[_i21]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Browser_IsPopup_args::~Server_Browser_IsPopup_args() noexcept {
}


uint32_t Server_Browser_IsPopup_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_IsPopup_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_IsPopup_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_IsPopup_pargs::~Server_Browser_IsPopup_pargs() noexcept {
}


uint32_t Server_Browser_IsPopup_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_IsPopup_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_IsPopup_result::~Server_Browser_IsPopup_result() noexcept {
}


uint32_t Server_Browser_IsPopup_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_IsPopup_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Browser_IsPopup_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_IsPopup_presult::~Server_Browser_IsPopup_presult() noexcept {
}


uint32_t Server_Browser_IsPopup_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Browser_HasDocument_args::~Server_Browser_HasDocument_args() noexcept {
}


uint32_t Server_Browser_HasDocument_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_HasDocument_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_HasDocument_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_HasDocument_pargs::~Server_Browser_HasDocument_pargs() noexcept {
}


uint32_t Server_Browser_HasDocument_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_HasDocument_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_HasDocument_result::~Server_Browser_HasDocument_result() noexcept {
}


uint32_t Server_Browser_HasDocument_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_HasDocument_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Browser_HasDocument_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_HasDocument_presult::~Server_Browser_HasDocument_presult() noexcept {
}


uint32_t Server_Browser_HasDocument_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Browser_ViewSource_args::~Server_Browser_ViewSource_args() noexcept {
}


uint32_t Server_Browser_ViewSource_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_ViewSource_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_ViewSource_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_ViewSource_pargs::~Server_Browser_ViewSource_pargs() noexcept {
}


uint32_t Server_Browser_ViewSource_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_ViewSource_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetSource_args::~Server_Browser_GetSource_args() noexcept {
}


uint32_t Server_Browser_GetSource_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stringVisitor.read(iprot);
          this->__isset.stringVisitor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_GetSource_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_GetSource_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stringVisitor", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->stringVisitor.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetSource_pargs::~Server_Browser_GetSource_pargs() noexcept {
}


uint32_t Server_Browser_GetSource_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_GetSource_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stringVisitor", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->stringVisitor)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetText_args::~Server_Browser_GetText_args() noexcept {
}


uint32_t Server_Browser_GetText_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stringVisitor.read(iprot);
          this->__isset.stringVisitor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_GetText_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_GetText_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stringVisitor", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->stringVisitor.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetText_pargs::~Server_Browser_GetText_pargs() noexcept {
}


uint32_t Server_Browser_GetText_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_GetText_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stringVisitor", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->stringVisitor)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_SetFocus_args::~Server_Browser_SetFocus_args() noexcept {
}


uint32_t Server_Browser_SetFocus_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enable);
          this->__isset.enable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_SetFocus_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_SetFocus_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enable", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->enable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_SetFocus_pargs::~Server_Browser_SetFocus_pargs() noexcept {
}


uint32_t Server_Browser_SetFocus_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_SetFocus_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enable", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->enable)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetZoomLevel_args::~Server_Browser_GetZoomLevel_args() noexcept {
}


uint32_t Server_Browser_GetZoomLevel_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_GetZoomLevel_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_GetZoomLevel_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetZoomLevel_pargs::~Server_Browser_GetZoomLevel_pargs() noexcept {
}


uint32_t Server_Browser_GetZoomLevel_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_GetZoomLevel_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetZoomLevel_result::~Server_Browser_GetZoomLevel_result() noexcept {
}


uint32_t Server_Browser_GetZoomLevel_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_GetZoomLevel_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Browser_GetZoomLevel_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_DOUBLE, 0);
    xfer += oprot->writeDouble(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetZoomLevel_presult::~Server_Browser_GetZoomLevel_presult() noexcept {
}


uint32_t Server_Browser_GetZoomLevel_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Browser_SetZoomLevel_args::~Server_Browser_SetZoomLevel_args() noexcept {
}


uint32_t Server_Browser_SetZoomLevel_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->val);
          this->__isset.val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_SetZoomLevel_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_SetZoomLevel_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("val", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->val);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_SetZoomLevel_pargs::~Server_Browser_SetZoomLevel_pargs() noexcept {
}


uint32_t Server_Browser_SetZoomLevel_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_SetZoomLevel_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("val", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble((*(this->val)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_StartDownload_args::~Server_Browser_StartDownload_args() noexcept {
}


uint32_t Server_Browser_StartDownload_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          this->__isset.url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_StartDownload_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_StartDownload_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_StartDownload_pargs::~Server_Browser_StartDownload_pargs() noexcept {
}


uint32_t Server_Browser_StartDownload_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_StartDownload_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->url)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_Find_args::~Server_Browser_Find_args() noexcept {
}


uint32_t Server_Browser_Find_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->searchText);
          this->__isset.searchText = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->forward);
          this->__isset.forward = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->matchCase);
          this->__isset.matchCase = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->findNext);
          this->__isset.findNext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_Find_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_Find_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("searchText", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->searchText);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("forward", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->forward);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("matchCase", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->matchCase);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("findNext", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->findNext);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_Find_pargs::~Server_Browser_Find_pargs() noexcept {
}


uint32_t Server_Browser_Find_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_Find_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("searchText", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->searchText)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("forward", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool((*(this->forward)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("matchCase", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool((*(this->matchCase)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("findNext", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool((*(this->findNext)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_StopFinding_args::~Server_Browser_StopFinding_args() noexcept {
}


uint32_t Server_Browser_StopFinding_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->clearSelection);
          this->__isset.clearSelection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_StopFinding_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_StopFinding_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("clearSelection", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->clearSelection);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_StopFinding_pargs::~Server_Browser_StopFinding_pargs() noexcept {
}


uint32_t Server_Browser_StopFinding_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_StopFinding_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("clearSelection", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->clearSelection)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_ReplaceMisspelling_args::~Server_Browser_ReplaceMisspelling_args() noexcept {
}


uint32_t Server_Browser_ReplaceMisspelling_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->word);
          this->__isset.word = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_ReplaceMisspelling_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_ReplaceMisspelling_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("word", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->word);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_ReplaceMisspelling_pargs::~Server_Browser_ReplaceMisspelling_pargs() noexcept {
}


uint32_t Server_Browser_ReplaceMisspelling_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_ReplaceMisspelling_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("word", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->word)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_SetFrameRate_args::~Server_Browser_SetFrameRate_args() noexcept {
}


uint32_t Server_Browser_SetFrameRate_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->val);
          this->__isset.val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_SetFrameRate_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_SetFrameRate_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("val", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->val);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_SetFrameRate_pargs::~Server_Browser_SetFrameRate_pargs() noexcept {
}


uint32_t Server_Browser_SetFrameRate_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_SetFrameRate_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("val", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->val)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Frame_ExecuteJavaScript_args::~Server_Frame_ExecuteJavaScript_args() noexcept {
}


uint32_t Server_Frame_ExecuteJavaScript_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->frameId);
          this->__isset.frameId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          this->__isset.url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->line);
          this->__isset.line = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Frame_ExecuteJavaScript_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Frame_ExecuteJavaScript_args");

  xfer += oprot->writeFieldBegin("frameId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->frameId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("line", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->line);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Frame_ExecuteJavaScript_pargs::~Server_Frame_ExecuteJavaScript_pargs() noexcept {
}


uint32_t Server_Frame_ExecuteJavaScript_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Frame_ExecuteJavaScript_pargs");

  xfer += oprot->writeFieldBegin("frameId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->frameId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->code)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->url)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("line", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->line)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Frame_Dispose_args::~Server_Frame_Dispose_args() noexcept {
}


uint32_t Server_Frame_Dispose_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->frameId);
          this->__isset.frameId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Frame_Dispose_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Frame_Dispose_args");

  xfer += oprot->writeFieldBegin("frameId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->frameId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Frame_Dispose_pargs::~Server_Frame_Dispose_pargs() noexcept {
}


uint32_t Server_Frame_Dispose_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Frame_Dispose_pargs");

  xfer += oprot->writeFieldBegin("frameId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->frameId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Frame_GetParent_args::~Server_Frame_GetParent_args() noexcept {
}


uint32_t Server_Frame_GetParent_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->frameId);
          this->__isset.frameId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Frame_GetParent_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Frame_GetParent_args");

  xfer += oprot->writeFieldBegin("frameId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->frameId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Frame_GetParent_pargs::~Server_Frame_GetParent_pargs() noexcept {
}


uint32_t Server_Frame_GetParent_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Frame_GetParent_pargs");

  xfer += oprot->writeFieldBegin("frameId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->frameId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Frame_GetParent_result::~Server_Frame_GetParent_result() noexcept {
}


uint32_t Server_Frame_GetParent_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Frame_GetParent_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Frame_GetParent_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Frame_GetParent_presult::~Server_Frame_GetParent_presult() noexcept {
}


uint32_t Server_Frame_GetParent_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Frame_Undo_args::~Server_Frame_Undo_args() noexcept {
}


uint32_t Server_Frame_Undo_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->frameId);
          this->__isset.frameId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Frame_Undo_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Frame_Undo_args");

  xfer += oprot->writeFieldBegin("frameId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->frameId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Frame_Undo_pargs::~Server_Frame_Undo_pargs() noexcept {
}


uint32_t Server_Frame_Undo_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Frame_Undo_pargs");

  xfer += oprot->writeFieldBegin("frameId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->frameId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Frame_Redo_args::~Server_Frame_Redo_args() noexcept {
}


uint32_t Server_Frame_Redo_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->frameId);
          this->__isset.frameId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Frame_Redo_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Frame_Redo_args");

  xfer += oprot->writeFieldBegin("frameId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->frameId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Frame_Redo_pargs::~Server_Frame_Redo_pargs() noexcept {
}


uint32_t Server_Frame_Redo_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Frame_Redo_pargs");

  xfer += oprot->writeFieldBegin("frameId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->frameId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Frame_Cut_args::~Server_Frame_Cut_args() noexcept {
}


uint32_t Server_Frame_Cut_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->frameId);
          this->__isset.frameId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Frame_Cut_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Frame_Cut_args");

  xfer += oprot->writeFieldBegin("frameId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->frameId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Frame_Cut_pargs::~Server_Frame_Cut_pargs() noexcept {
}


uint32_t Server_Frame_Cut_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Frame_Cut_pargs");

  xfer += oprot->writeFieldBegin("frameId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->frameId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Frame_Copy_args::~Server_Frame_Copy_args() noexcept {
}


uint32_t Server_Frame_Copy_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->frameId);
          this->__isset.frameId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Frame_Copy_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Frame_Copy_args");

  xfer += oprot->writeFieldBegin("frameId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->frameId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Frame_Copy_pargs::~Server_Frame_Copy_pargs() noexcept {
}


uint32_t Server_Frame_Copy_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Frame_Copy_pargs");

  xfer += oprot->writeFieldBegin("frameId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->frameId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Frame_Paste_args::~Server_Frame_Paste_args() noexcept {
}


uint32_t Server_Frame_Paste_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->frameId);
          this->__isset.frameId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Frame_Paste_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Frame_Paste_args");

  xfer += oprot->writeFieldBegin("frameId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->frameId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Frame_Paste_pargs::~Server_Frame_Paste_pargs() noexcept {
}


uint32_t Server_Frame_Paste_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Frame_Paste_pargs");

  xfer += oprot->writeFieldBegin("frameId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->frameId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Frame_Delete_args::~Server_Frame_Delete_args() noexcept {
}


uint32_t Server_Frame_Delete_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->frameId);
          this->__isset.frameId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Frame_Delete_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Frame_Delete_args");

  xfer += oprot->writeFieldBegin("frameId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->frameId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Frame_Delete_pargs::~Server_Frame_Delete_pargs() noexcept {
}


uint32_t Server_Frame_Delete_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Frame_Delete_pargs");

  xfer += oprot->writeFieldBegin("frameId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->frameId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Frame_SelectAll_args::~Server_Frame_SelectAll_args() noexcept {
}


uint32_t Server_Frame_SelectAll_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->frameId);
          this->__isset.frameId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Frame_SelectAll_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Frame_SelectAll_args");

  xfer += oprot->writeFieldBegin("frameId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->frameId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Frame_SelectAll_pargs::~Server_Frame_SelectAll_pargs() noexcept {
}


uint32_t Server_Frame_SelectAll_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Frame_SelectAll_pargs");

  xfer += oprot->writeFieldBegin("frameId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->frameId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_Create_args::~Server_Request_Create_args() noexcept {
}


uint32_t Server_Request_Create_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_Create_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_Create_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_Create_pargs::~Server_Request_Create_pargs() noexcept {
}


uint32_t Server_Request_Create_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_Create_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_Create_result::~Server_Request_Create_result() noexcept {
}


uint32_t Server_Request_Create_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_Create_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Request_Create_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_Create_presult::~Server_Request_Create_presult() noexcept {
}


uint32_t Server_Request_Create_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Request_Dispose_args::~Server_Request_Dispose_args() noexcept {
}


uint32_t Server_Request_Dispose_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->requestId);
          this->__isset.requestId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_Dispose_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_Dispose_args");

  xfer += oprot->writeFieldBegin("requestId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->requestId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_Dispose_pargs::~Server_Request_Dispose_pargs() noexcept {
}


uint32_t Server_Request_Dispose_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_Dispose_pargs");

  xfer += oprot->writeFieldBegin("requestId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->requestId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_Update_args::~Server_Request_Update_args() noexcept {
}


uint32_t Server_Request_Update_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_Update_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_Update_args");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_Update_pargs::~Server_Request_Update_pargs() noexcept {
}


uint32_t Server_Request_Update_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_Update_pargs");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->request)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_Update_result::~Server_Request_Update_result() noexcept {
}


uint32_t Server_Request_Update_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_Update_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Request_Update_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_Update_presult::~Server_Request_Update_presult() noexcept {
}


uint32_t Server_Request_Update_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Request_GetPostData_args::~Server_Request_GetPostData_args() noexcept {
}


uint32_t Server_Request_GetPostData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_GetPostData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_GetPostData_args");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_GetPostData_pargs::~Server_Request_GetPostData_pargs() noexcept {
}


uint32_t Server_Request_GetPostData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_GetPostData_pargs");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->request)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_GetPostData_result::~Server_Request_GetPostData_result() noexcept {
}


uint32_t Server_Request_GetPostData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_GetPostData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Request_GetPostData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_GetPostData_presult::~Server_Request_GetPostData_presult() noexcept {
}


uint32_t Server_Request_GetPostData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Request_SetPostData_args::~Server_Request_SetPostData_args() noexcept {
}


uint32_t Server_Request_SetPostData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->postData.read(iprot);
          this->__isset.postData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_SetPostData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_SetPostData_args");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("postData", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->postData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_SetPostData_pargs::~Server_Request_SetPostData_pargs() noexcept {
}


uint32_t Server_Request_SetPostData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_SetPostData_pargs");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->request)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("postData", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->postData)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_SetPostData_result::~Server_Request_SetPostData_result() noexcept {
}


uint32_t Server_Request_SetPostData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_SetPostData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Request_SetPostData_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_SetPostData_presult::~Server_Request_SetPostData_presult() noexcept {
}


uint32_t Server_Request_SetPostData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Request_GetHeaderByName_args::~Server_Request_GetHeaderByName_args() noexcept {
}


uint32_t Server_Request_GetHeaderByName_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_GetHeaderByName_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_GetHeaderByName_args");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_GetHeaderByName_pargs::~Server_Request_GetHeaderByName_pargs() noexcept {
}


uint32_t Server_Request_GetHeaderByName_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_GetHeaderByName_pargs");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->request)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->name)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_GetHeaderByName_result::~Server_Request_GetHeaderByName_result() noexcept {
}


uint32_t Server_Request_GetHeaderByName_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_GetHeaderByName_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Request_GetHeaderByName_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_GetHeaderByName_presult::~Server_Request_GetHeaderByName_presult() noexcept {
}


uint32_t Server_Request_GetHeaderByName_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Request_SetHeaderByName_args::~Server_Request_SetHeaderByName_args() noexcept {
}


uint32_t Server_Request_SetHeaderByName_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->overwrite);
          this->__isset.overwrite = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_SetHeaderByName_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_SetHeaderByName_args");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("overwrite", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->overwrite);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_SetHeaderByName_pargs::~Server_Request_SetHeaderByName_pargs() noexcept {
}


uint32_t Server_Request_SetHeaderByName_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_SetHeaderByName_pargs");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->request)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->name)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->value)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("overwrite", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool((*(this->overwrite)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_SetHeaderByName_result::~Server_Request_SetHeaderByName_result() noexcept {
}


uint32_t Server_Request_SetHeaderByName_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_SetHeaderByName_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Request_SetHeaderByName_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_SetHeaderByName_presult::~Server_Request_SetHeaderByName_presult() noexcept {
}


uint32_t Server_Request_SetHeaderByName_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Request_GetHeaderMap_args::~Server_Request_GetHeaderMap_args() noexcept {
}


uint32_t Server_Request_GetHeaderMap_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_GetHeaderMap_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_GetHeaderMap_args");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_GetHeaderMap_pargs::~Server_Request_GetHeaderMap_pargs() noexcept {
}


uint32_t Server_Request_GetHeaderMap_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_GetHeaderMap_pargs");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->request)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_GetHeaderMap_result::~Server_Request_GetHeaderMap_result() noexcept {
}


uint32_t Server_Request_GetHeaderMap_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _ktype23;
            ::apache::thrift::protocol::TType _vtype24;
            xfer += iprot->readMapBegin(_ktype23, _vtype24, _size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              std::string _key27;
              xfer += iprot->readString(_key27);
              std::string& _val28 = this->success[_key27];
              xfer += iprot->readString(_val28);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_GetHeaderMap_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Request_GetHeaderMap_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::map<std::string, std::string> ::const_iterator _iter29;
      for (_iter29 = this->success.begin(); _iter29 != this->success.end(); ++_iter29)
      {
        xfer += oprot->writeString(_iter29->first);
        xfer += oprot->writeString(_iter29->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_GetHeaderMap_presult::~Server_Request_GetHeaderMap_presult() noexcept {
}


uint32_t Server_Request_GetHeaderMap_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size30;
            ::apache::thrift::protocol::TType _ktype31;
            ::apache::thrift::protocol::TType _vtype32;
            xfer += iprot->readMapBegin(_ktype31, _vtype32, _size30);
            uint32_t _i34;
            for (_i34 = 0; _i34 < _size30; ++_i34)
            {
              std::string _key35;
              xfer += iprot->readString(_key35);
              std::string& _val36 = (*(this->success))[_key35];
              xfer += iprot->readString(_val36);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Request_SetHeaderMap_args::~Server_Request_SetHeaderMap_args() noexcept {
}


uint32_t Server_Request_SetHeaderMap_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->headerMap.clear();
            uint32_t _size37;
            ::apache::thrift::protocol::TType _ktype38;
            ::apache::thrift::protocol::TType _vtype39;
            xfer += iprot->readMapBegin(_ktype38, _vtype39, _size37);
            uint32_t _i41;
            for (_i41 = 0; _i41 < _size37; ++_i41)
            {
              std::string _key42;
              xfer += iprot->readString(_key42);
              std::string& _val43 = this->headerMap[_key42];
              xfer += iprot->readString(_val43);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.headerMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_SetHeaderMap_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_SetHeaderMap_args");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("headerMap", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->headerMap.size()));
    std::map<std::string, std::string> ::const_iterator _iter44;
    for (_iter44 = this->headerMap.begin(); _iter44 != this->headerMap.end(); ++_iter44)
    {
      xfer += oprot->writeString(_iter44->first);
      xfer += oprot->writeString(_iter44->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_SetHeaderMap_pargs::~Server_Request_SetHeaderMap_pargs() noexcept {
}


uint32_t Server_Request_SetHeaderMap_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_SetHeaderMap_pargs");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->request)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("headerMap", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->headerMap)).size()));
    std::map<std::string, std::string> ::const_iterator _iter45;
    for (_iter45 = (*(this->headerMap)).begin(); _iter45 != (*(this->headerMap)).end(); ++_iter45)
    {
      xfer += oprot->writeString(_iter45->first);
      xfer += oprot->writeString(_iter45->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_SetHeaderMap_result::~Server_Request_SetHeaderMap_result() noexcept {
}


uint32_t Server_Request_SetHeaderMap_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_SetHeaderMap_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Request_SetHeaderMap_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_SetHeaderMap_presult::~Server_Request_SetHeaderMap_presult() noexcept {
}


uint32_t Server_Request_SetHeaderMap_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Request_Set_args::~Server_Request_Set_args() noexcept {
}


uint32_t Server_Request_Set_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          this->__isset.url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->method);
          this->__isset.method = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->postData.read(iprot);
          this->__isset.postData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->headerMap.clear();
            uint32_t _size46;
            ::apache::thrift::protocol::TType _ktype47;
            ::apache::thrift::protocol::TType _vtype48;
            xfer += iprot->readMapBegin(_ktype47, _vtype48, _size46);
            uint32_t _i50;
            for (_i50 = 0; _i50 < _size46; ++_i50)
            {
              std::string _key51;
              xfer += iprot->readString(_key51);
              std::string& _val52 = this->headerMap[_key51];
              xfer += iprot->readString(_val52);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.headerMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_Set_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_Set_args");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("method", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->method);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("postData", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->postData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("headerMap", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->headerMap.size()));
    std::map<std::string, std::string> ::const_iterator _iter53;
    for (_iter53 = this->headerMap.begin(); _iter53 != this->headerMap.end(); ++_iter53)
    {
      xfer += oprot->writeString(_iter53->first);
      xfer += oprot->writeString(_iter53->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_Set_pargs::~Server_Request_Set_pargs() noexcept {
}


uint32_t Server_Request_Set_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_Set_pargs");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->request)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->url)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("method", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->method)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("postData", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += (*(this->postData)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("headerMap", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->headerMap)).size()));
    std::map<std::string, std::string> ::const_iterator _iter54;
    for (_iter54 = (*(this->headerMap)).begin(); _iter54 != (*(this->headerMap)).end(); ++_iter54)
    {
      xfer += oprot->writeString(_iter54->first);
      xfer += oprot->writeString(_iter54->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_Set_result::~Server_Request_Set_result() noexcept {
}


uint32_t Server_Request_Set_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_Set_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Request_Set_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_Set_presult::~Server_Request_Set_presult() noexcept {
}


uint32_t Server_Request_Set_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Response_Update_args::~Server_Response_Update_args() noexcept {
}


uint32_t Server_Response_Update_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->response.read(iprot);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Response_Update_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Response_Update_args");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->response.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Response_Update_pargs::~Server_Response_Update_pargs() noexcept {
}


uint32_t Server_Response_Update_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Response_Update_pargs");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->response)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Response_Update_result::~Server_Response_Update_result() noexcept {
}


uint32_t Server_Response_Update_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Response_Update_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Response_Update_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Response_Update_presult::~Server_Response_Update_presult() noexcept {
}


uint32_t Server_Response_Update_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Response_GetHeaderByName_args::~Server_Response_GetHeaderByName_args() noexcept {
}


uint32_t Server_Response_GetHeaderByName_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->response.read(iprot);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Response_GetHeaderByName_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Response_GetHeaderByName_args");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->response.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Response_GetHeaderByName_pargs::~Server_Response_GetHeaderByName_pargs() noexcept {
}


uint32_t Server_Response_GetHeaderByName_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Response_GetHeaderByName_pargs");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->response)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->name)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Response_GetHeaderByName_result::~Server_Response_GetHeaderByName_result() noexcept {
}


uint32_t Server_Response_GetHeaderByName_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Response_GetHeaderByName_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Response_GetHeaderByName_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Response_GetHeaderByName_presult::~Server_Response_GetHeaderByName_presult() noexcept {
}


uint32_t Server_Response_GetHeaderByName_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Response_SetHeaderByName_args::~Server_Response_SetHeaderByName_args() noexcept {
}


uint32_t Server_Response_SetHeaderByName_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->response.read(iprot);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->overwrite);
          this->__isset.overwrite = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Response_SetHeaderByName_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Response_SetHeaderByName_args");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->response.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("overwrite", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->overwrite);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Response_SetHeaderByName_pargs::~Server_Response_SetHeaderByName_pargs() noexcept {
}


uint32_t Server_Response_SetHeaderByName_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Response_SetHeaderByName_pargs");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->response)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->name)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->value)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("overwrite", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool((*(this->overwrite)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Response_SetHeaderByName_result::~Server_Response_SetHeaderByName_result() noexcept {
}


uint32_t Server_Response_SetHeaderByName_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Response_SetHeaderByName_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Response_SetHeaderByName_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Response_SetHeaderByName_presult::~Server_Response_SetHeaderByName_presult() noexcept {
}


uint32_t Server_Response_SetHeaderByName_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Response_GetHeaderMap_args::~Server_Response_GetHeaderMap_args() noexcept {
}


uint32_t Server_Response_GetHeaderMap_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->response.read(iprot);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Response_GetHeaderMap_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Response_GetHeaderMap_args");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->response.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Response_GetHeaderMap_pargs::~Server_Response_GetHeaderMap_pargs() noexcept {
}


uint32_t Server_Response_GetHeaderMap_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Response_GetHeaderMap_pargs");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->response)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Response_GetHeaderMap_result::~Server_Response_GetHeaderMap_result() noexcept {
}


uint32_t Server_Response_GetHeaderMap_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size55;
            ::apache::thrift::protocol::TType _ktype56;
            ::apache::thrift::protocol::TType _vtype57;
            xfer += iprot->readMapBegin(_ktype56, _vtype57, _size55);
            uint32_t _i59;
            for (_i59 = 0; _i59 < _size55; ++_i59)
            {
              std::string _key60;
              xfer += iprot->readString(_key60);
              std::string& _val61 = this->success[_key60];
              xfer += iprot->readString(_val61);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Response_GetHeaderMap_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Response_GetHeaderMap_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::map<std::string, std::string> ::const_iterator _iter62;
      for (_iter62 = this->success.begin(); _iter62 != this->success.end(); ++_iter62)
      {
        xfer += oprot->writeString(_iter62->first);
        xfer += oprot->writeString(_iter62->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Response_GetHeaderMap_presult::~Server_Response_GetHeaderMap_presult() noexcept {
}


uint32_t Server_Response_GetHeaderMap_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size63;
            ::apache::thrift::protocol::TType _ktype64;
            ::apache::thrift::protocol::TType _vtype65;
            xfer += iprot->readMapBegin(_ktype64, _vtype65, _size63);
            uint32_t _i67;
            for (_i67 = 0; _i67 < _size63; ++_i67)
            {
              std::string _key68;
              xfer += iprot->readString(_key68);
              std::string& _val69 = (*(this->success))[_key68];
              xfer += iprot->readString(_val69);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Response_SetHeaderMap_args::~Server_Response_SetHeaderMap_args() noexcept {
}


uint32_t Server_Response_SetHeaderMap_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->response.read(iprot);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->headerMap.clear();
            uint32_t _size70;
            ::apache::thrift::protocol::TType _ktype71;
            ::apache::thrift::protocol::TType _vtype72;
            xfer += iprot->readMapBegin(_ktype71, _vtype72, _size70);
            uint32_t _i74;
            for (_i74 = 0; _i74 < _size70; ++_i74)
            {
              std::string _key75;
              xfer += iprot->readString(_key75);
              std::string& _val76 = this->headerMap[_key75];
              xfer += iprot->readString(_val76);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.headerMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Response_SetHeaderMap_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Response_SetHeaderMap_args");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->response.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("headerMap", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->headerMap.size()));
    std::map<std::string, std::string> ::const_iterator _iter77;
    for (_iter77 = this->headerMap.begin(); _iter77 != this->headerMap.end(); ++_iter77)
    {
      xfer += oprot->writeString(_iter77->first);
      xfer += oprot->writeString(_iter77->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Response_SetHeaderMap_pargs::~Server_Response_SetHeaderMap_pargs() noexcept {
}


uint32_t Server_Response_SetHeaderMap_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Response_SetHeaderMap_pargs");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->response)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("headerMap", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->headerMap)).size()));
    std::map<std::string, std::string> ::const_iterator _iter78;
    for (_iter78 = (*(this->headerMap)).begin(); _iter78 != (*(this->headerMap)).end(); ++_iter78)
    {
      xfer += oprot->writeString(_iter78->first);
      xfer += oprot->writeString(_iter78->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Response_SetHeaderMap_result::~Server_Response_SetHeaderMap_result() noexcept {
}


uint32_t Server_Response_SetHeaderMap_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Response_SetHeaderMap_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Response_SetHeaderMap_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Response_SetHeaderMap_presult::~Server_Response_SetHeaderMap_presult() noexcept {
}


uint32_t Server_Response_SetHeaderMap_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Callback_Dispose_args::~Server_Callback_Dispose_args() noexcept {
}


uint32_t Server_Callback_Dispose_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->callback.read(iprot);
          this->__isset.callback = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Callback_Dispose_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Callback_Dispose_args");

  xfer += oprot->writeFieldBegin("callback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->callback.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Callback_Dispose_pargs::~Server_Callback_Dispose_pargs() noexcept {
}


uint32_t Server_Callback_Dispose_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Callback_Dispose_pargs");

  xfer += oprot->writeFieldBegin("callback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->callback)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Callback_Continue_args::~Server_Callback_Continue_args() noexcept {
}


uint32_t Server_Callback_Continue_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->callback.read(iprot);
          this->__isset.callback = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Callback_Continue_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Callback_Continue_args");

  xfer += oprot->writeFieldBegin("callback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->callback.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Callback_Continue_pargs::~Server_Callback_Continue_pargs() noexcept {
}


uint32_t Server_Callback_Continue_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Callback_Continue_pargs");

  xfer += oprot->writeFieldBegin("callback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->callback)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Callback_Cancel_args::~Server_Callback_Cancel_args() noexcept {
}


uint32_t Server_Callback_Cancel_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->callback.read(iprot);
          this->__isset.callback = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Callback_Cancel_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Callback_Cancel_args");

  xfer += oprot->writeFieldBegin("callback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->callback.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Callback_Cancel_pargs::~Server_Callback_Cancel_pargs() noexcept {
}


uint32_t Server_Callback_Cancel_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Callback_Cancel_pargs");

  xfer += oprot->writeFieldBegin("callback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->callback)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_AuthCallback_Dispose_args::~Server_AuthCallback_Dispose_args() noexcept {
}


uint32_t Server_AuthCallback_Dispose_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->authCallback.read(iprot);
          this->__isset.authCallback = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_AuthCallback_Dispose_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_AuthCallback_Dispose_args");

  xfer += oprot->writeFieldBegin("authCallback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->authCallback.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_AuthCallback_Dispose_pargs::~Server_AuthCallback_Dispose_pargs() noexcept {
}


uint32_t Server_AuthCallback_Dispose_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_AuthCallback_Dispose_pargs");

  xfer += oprot->writeFieldBegin("authCallback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->authCallback)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_AuthCallback_Continue_args::~Server_AuthCallback_Continue_args() noexcept {
}


uint32_t Server_AuthCallback_Continue_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->authCallback.read(iprot);
          this->__isset.authCallback = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_AuthCallback_Continue_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_AuthCallback_Continue_args");

  xfer += oprot->writeFieldBegin("authCallback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->authCallback.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->username);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->password);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_AuthCallback_Continue_pargs::~Server_AuthCallback_Continue_pargs() noexcept {
}


uint32_t Server_AuthCallback_Continue_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_AuthCallback_Continue_pargs");

  xfer += oprot->writeFieldBegin("authCallback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->authCallback)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->username)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->password)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_AuthCallback_Cancel_args::~Server_AuthCallback_Cancel_args() noexcept {
}


uint32_t Server_AuthCallback_Cancel_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->authCallback.read(iprot);
          this->__isset.authCallback = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_AuthCallback_Cancel_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_AuthCallback_Cancel_args");

  xfer += oprot->writeFieldBegin("authCallback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->authCallback.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_AuthCallback_Cancel_pargs::~Server_AuthCallback_Cancel_pargs() noexcept {
}


uint32_t Server_AuthCallback_Cancel_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_AuthCallback_Cancel_pargs");

  xfer += oprot->writeFieldBegin("authCallback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->authCallback)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_Create_args::~Server_MessageRouter_Create_args() noexcept {
}


uint32_t Server_MessageRouter_Create_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->query);
          this->__isset.query = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cancel);
          this->__isset.cancel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_MessageRouter_Create_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_MessageRouter_Create_args");

  xfer += oprot->writeFieldBegin("query", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->query);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cancel", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->cancel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_Create_pargs::~Server_MessageRouter_Create_pargs() noexcept {
}


uint32_t Server_MessageRouter_Create_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_MessageRouter_Create_pargs");

  xfer += oprot->writeFieldBegin("query", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->query)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cancel", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->cancel)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_Create_result::~Server_MessageRouter_Create_result() noexcept {
}


uint32_t Server_MessageRouter_Create_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_MessageRouter_Create_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_MessageRouter_Create_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_Create_presult::~Server_MessageRouter_Create_presult() noexcept {
}


uint32_t Server_MessageRouter_Create_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_MessageRouter_Dispose_args::~Server_MessageRouter_Dispose_args() noexcept {
}


uint32_t Server_MessageRouter_Dispose_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->msgRouter.read(iprot);
          this->__isset.msgRouter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_MessageRouter_Dispose_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_MessageRouter_Dispose_args");

  xfer += oprot->writeFieldBegin("msgRouter", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->msgRouter.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_Dispose_pargs::~Server_MessageRouter_Dispose_pargs() noexcept {
}


uint32_t Server_MessageRouter_Dispose_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_MessageRouter_Dispose_pargs");

  xfer += oprot->writeFieldBegin("msgRouter", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->msgRouter)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_AddMessageRouterToBrowser_args::~Server_MessageRouter_AddMessageRouterToBrowser_args() noexcept {
}


uint32_t Server_MessageRouter_AddMessageRouterToBrowser_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->msgRouter.read(iprot);
          this->__isset.msgRouter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_MessageRouter_AddMessageRouterToBrowser_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_MessageRouter_AddMessageRouterToBrowser_args");

  xfer += oprot->writeFieldBegin("msgRouter", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->msgRouter.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_AddMessageRouterToBrowser_pargs::~Server_MessageRouter_AddMessageRouterToBrowser_pargs() noexcept {
}


uint32_t Server_MessageRouter_AddMessageRouterToBrowser_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_MessageRouter_AddMessageRouterToBrowser_pargs");

  xfer += oprot->writeFieldBegin("msgRouter", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->msgRouter)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_AddMessageRouterToBrowser_result::~Server_MessageRouter_AddMessageRouterToBrowser_result() noexcept {
}


uint32_t Server_MessageRouter_AddMessageRouterToBrowser_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_MessageRouter_AddMessageRouterToBrowser_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_MessageRouter_AddMessageRouterToBrowser_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_AddMessageRouterToBrowser_presult::~Server_MessageRouter_AddMessageRouterToBrowser_presult() noexcept {
}


uint32_t Server_MessageRouter_AddMessageRouterToBrowser_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_MessageRouter_RemoveMessageRouterFromBrowser_args::~Server_MessageRouter_RemoveMessageRouterFromBrowser_args() noexcept {
}


uint32_t Server_MessageRouter_RemoveMessageRouterFromBrowser_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->msgRouter.read(iprot);
          this->__isset.msgRouter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_MessageRouter_RemoveMessageRouterFromBrowser_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_MessageRouter_RemoveMessageRouterFromBrowser_args");

  xfer += oprot->writeFieldBegin("msgRouter", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->msgRouter.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_RemoveMessageRouterFromBrowser_pargs::~Server_MessageRouter_RemoveMessageRouterFromBrowser_pargs() noexcept {
}


uint32_t Server_MessageRouter_RemoveMessageRouterFromBrowser_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_MessageRouter_RemoveMessageRouterFromBrowser_pargs");

  xfer += oprot->writeFieldBegin("msgRouter", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->msgRouter)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_RemoveMessageRouterFromBrowser_result::~Server_MessageRouter_RemoveMessageRouterFromBrowser_result() noexcept {
}


uint32_t Server_MessageRouter_RemoveMessageRouterFromBrowser_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_MessageRouter_RemoveMessageRouterFromBrowser_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_MessageRouter_RemoveMessageRouterFromBrowser_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_RemoveMessageRouterFromBrowser_presult::~Server_MessageRouter_RemoveMessageRouterFromBrowser_presult() noexcept {
}


uint32_t Server_MessageRouter_RemoveMessageRouterFromBrowser_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_MessageRouter_AddHandler_args::~Server_MessageRouter_AddHandler_args() noexcept {
}


uint32_t Server_MessageRouter_AddHandler_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->msgRouter.read(iprot);
          this->__isset.msgRouter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->handler.read(iprot);
          this->__isset.handler = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->first);
          this->__isset.first = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_MessageRouter_AddHandler_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_MessageRouter_AddHandler_args");

  xfer += oprot->writeFieldBegin("msgRouter", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->msgRouter.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("handler", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->handler.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("first", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->first);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_AddHandler_pargs::~Server_MessageRouter_AddHandler_pargs() noexcept {
}


uint32_t Server_MessageRouter_AddHandler_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_MessageRouter_AddHandler_pargs");

  xfer += oprot->writeFieldBegin("msgRouter", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->msgRouter)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("handler", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->handler)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("first", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool((*(this->first)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_AddHandler_result::~Server_MessageRouter_AddHandler_result() noexcept {
}


uint32_t Server_MessageRouter_AddHandler_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_MessageRouter_AddHandler_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_MessageRouter_AddHandler_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_AddHandler_presult::~Server_MessageRouter_AddHandler_presult() noexcept {
}


uint32_t Server_MessageRouter_AddHandler_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_MessageRouter_RemoveHandler_args::~Server_MessageRouter_RemoveHandler_args() noexcept {
}


uint32_t Server_MessageRouter_RemoveHandler_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->msgRouter.read(iprot);
          this->__isset.msgRouter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->handler.read(iprot);
          this->__isset.handler = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_MessageRouter_RemoveHandler_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_MessageRouter_RemoveHandler_args");

  xfer += oprot->writeFieldBegin("msgRouter", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->msgRouter.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("handler", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->handler.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_RemoveHandler_pargs::~Server_MessageRouter_RemoveHandler_pargs() noexcept {
}


uint32_t Server_MessageRouter_RemoveHandler_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_MessageRouter_RemoveHandler_pargs");

  xfer += oprot->writeFieldBegin("msgRouter", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->msgRouter)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("handler", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->handler)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_RemoveHandler_result::~Server_MessageRouter_RemoveHandler_result() noexcept {
}


uint32_t Server_MessageRouter_RemoveHandler_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_MessageRouter_RemoveHandler_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_MessageRouter_RemoveHandler_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_RemoveHandler_presult::~Server_MessageRouter_RemoveHandler_presult() noexcept {
}


uint32_t Server_MessageRouter_RemoveHandler_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_MessageRouter_CancelPending_args::~Server_MessageRouter_CancelPending_args() noexcept {
}


uint32_t Server_MessageRouter_CancelPending_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->msgRouter.read(iprot);
          this->__isset.msgRouter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->handler.read(iprot);
          this->__isset.handler = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_MessageRouter_CancelPending_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_MessageRouter_CancelPending_args");

  xfer += oprot->writeFieldBegin("msgRouter", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->msgRouter.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("handler", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->handler.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_CancelPending_pargs::~Server_MessageRouter_CancelPending_pargs() noexcept {
}


uint32_t Server_MessageRouter_CancelPending_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_MessageRouter_CancelPending_pargs");

  xfer += oprot->writeFieldBegin("msgRouter", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->msgRouter)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("handler", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->handler)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_CancelPending_result::~Server_MessageRouter_CancelPending_result() noexcept {
}


uint32_t Server_MessageRouter_CancelPending_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_MessageRouter_CancelPending_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_MessageRouter_CancelPending_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_CancelPending_presult::~Server_MessageRouter_CancelPending_presult() noexcept {
}


uint32_t Server_MessageRouter_CancelPending_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_QueryCallback_Dispose_args::~Server_QueryCallback_Dispose_args() noexcept {
}


uint32_t Server_QueryCallback_Dispose_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->qcallback.read(iprot);
          this->__isset.qcallback = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_QueryCallback_Dispose_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_QueryCallback_Dispose_args");

  xfer += oprot->writeFieldBegin("qcallback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->qcallback.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_QueryCallback_Dispose_pargs::~Server_QueryCallback_Dispose_pargs() noexcept {
}


uint32_t Server_QueryCallback_Dispose_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_QueryCallback_Dispose_pargs");

  xfer += oprot->writeFieldBegin("qcallback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->qcallback)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_QueryCallback_Success_args::~Server_QueryCallback_Success_args() noexcept {
}


uint32_t Server_QueryCallback_Success_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->qcallback.read(iprot);
          this->__isset.qcallback = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_QueryCallback_Success_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_QueryCallback_Success_args");

  xfer += oprot->writeFieldBegin("qcallback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->qcallback.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_QueryCallback_Success_pargs::~Server_QueryCallback_Success_pargs() noexcept {
}


uint32_t Server_QueryCallback_Success_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_QueryCallback_Success_pargs");

  xfer += oprot->writeFieldBegin("qcallback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->qcallback)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->response)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_QueryCallback_Failure_args::~Server_QueryCallback_Failure_args() noexcept {
}


uint32_t Server_QueryCallback_Failure_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->qcallback.read(iprot);
          this->__isset.qcallback = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->error_code);
          this->__isset.error_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_message);
          this->__isset.error_message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_QueryCallback_Failure_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_QueryCallback_Failure_args");

  xfer += oprot->writeFieldBegin("qcallback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->qcallback.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_code", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->error_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_message", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->error_message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_QueryCallback_Failure_pargs::~Server_QueryCallback_Failure_pargs() noexcept {
}


uint32_t Server_QueryCallback_Failure_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_QueryCallback_Failure_pargs");

  xfer += oprot->writeFieldBegin("qcallback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->qcallback)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_code", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->error_code)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_message", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->error_message)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_SchemeHandlerFactory_Register_args::~Server_SchemeHandlerFactory_Register_args() noexcept {
}


uint32_t Server_SchemeHandlerFactory_Register_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schemeName);
          this->__isset.schemeName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->domainName);
          this->__isset.domainName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->schemeHandlerFactory.read(iprot);
          this->__isset.schemeHandlerFactory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_SchemeHandlerFactory_Register_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_SchemeHandlerFactory_Register_args");

  xfer += oprot->writeFieldBegin("schemeName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->schemeName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("domainName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->domainName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schemeHandlerFactory", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->schemeHandlerFactory.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_SchemeHandlerFactory_Register_pargs::~Server_SchemeHandlerFactory_Register_pargs() noexcept {
}


uint32_t Server_SchemeHandlerFactory_Register_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_SchemeHandlerFactory_Register_pargs");

  xfer += oprot->writeFieldBegin("schemeName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->schemeName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("domainName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->domainName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schemeHandlerFactory", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->schemeHandlerFactory)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_ClearAllSchemeHandlerFactories_args::~Server_ClearAllSchemeHandlerFactories_args() noexcept {
}


uint32_t Server_ClearAllSchemeHandlerFactories_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_ClearAllSchemeHandlerFactories_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_ClearAllSchemeHandlerFactories_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_ClearAllSchemeHandlerFactories_pargs::~Server_ClearAllSchemeHandlerFactories_pargs() noexcept {
}


uint32_t Server_ClearAllSchemeHandlerFactories_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_ClearAllSchemeHandlerFactories_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_RequestContext_ClearCertificateExceptions_args::~Server_RequestContext_ClearCertificateExceptions_args() noexcept {
}


uint32_t Server_RequestContext_ClearCertificateExceptions_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->completionCallback.read(iprot);
          this->__isset.completionCallback = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_RequestContext_ClearCertificateExceptions_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_RequestContext_ClearCertificateExceptions_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("completionCallback", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->completionCallback.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_RequestContext_ClearCertificateExceptions_pargs::~Server_RequestContext_ClearCertificateExceptions_pargs() noexcept {
}


uint32_t Server_RequestContext_ClearCertificateExceptions_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_RequestContext_ClearCertificateExceptions_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("completionCallback", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->completionCallback)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_RequestContext_CloseAllConnections_args::~Server_RequestContext_CloseAllConnections_args() noexcept {
}


uint32_t Server_RequestContext_CloseAllConnections_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->completionCallback.read(iprot);
          this->__isset.completionCallback = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_RequestContext_CloseAllConnections_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_RequestContext_CloseAllConnections_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("completionCallback", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->completionCallback.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_RequestContext_CloseAllConnections_pargs::~Server_RequestContext_CloseAllConnections_pargs() noexcept {
}


uint32_t Server_RequestContext_CloseAllConnections_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_RequestContext_CloseAllConnections_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("completionCallback", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->completionCallback)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_CookieManager_Create_args::~Server_CookieManager_Create_args() noexcept {
}


uint32_t Server_CookieManager_Create_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_CookieManager_Create_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_CookieManager_Create_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_CookieManager_Create_pargs::~Server_CookieManager_Create_pargs() noexcept {
}


uint32_t Server_CookieManager_Create_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_CookieManager_Create_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_CookieManager_Create_result::~Server_CookieManager_Create_result() noexcept {
}


uint32_t Server_CookieManager_Create_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_CookieManager_Create_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_CookieManager_Create_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_CookieManager_Create_presult::~Server_CookieManager_Create_presult() noexcept {
}


uint32_t Server_CookieManager_Create_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_CookieManager_Dispose_args::~Server_CookieManager_Dispose_args() noexcept {
}


uint32_t Server_CookieManager_Dispose_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cookieManager.read(iprot);
          this->__isset.cookieManager = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_CookieManager_Dispose_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_CookieManager_Dispose_args");

  xfer += oprot->writeFieldBegin("cookieManager", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->cookieManager.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_CookieManager_Dispose_pargs::~Server_CookieManager_Dispose_pargs() noexcept {
}


uint32_t Server_CookieManager_Dispose_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_CookieManager_Dispose_pargs");

  xfer += oprot->writeFieldBegin("cookieManager", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->cookieManager)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_CookieManager_VisitAllCookies_args::~Server_CookieManager_VisitAllCookies_args() noexcept {
}


uint32_t Server_CookieManager_VisitAllCookies_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cookieManager.read(iprot);
          this->__isset.cookieManager = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->visitor.read(iprot);
          this->__isset.visitor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_CookieManager_VisitAllCookies_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_CookieManager_VisitAllCookies_args");

  xfer += oprot->writeFieldBegin("cookieManager", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->cookieManager.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("visitor", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->visitor.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_CookieManager_VisitAllCookies_pargs::~Server_CookieManager_VisitAllCookies_pargs() noexcept {
}


uint32_t Server_CookieManager_VisitAllCookies_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_CookieManager_VisitAllCookies_pargs");

  xfer += oprot->writeFieldBegin("cookieManager", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->cookieManager)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("visitor", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->visitor)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_CookieManager_VisitAllCookies_result::~Server_CookieManager_VisitAllCookies_result() noexcept {
}


uint32_t Server_CookieManager_VisitAllCookies_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_CookieManager_VisitAllCookies_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_CookieManager_VisitAllCookies_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_CookieManager_VisitAllCookies_presult::~Server_CookieManager_VisitAllCookies_presult() noexcept {
}


uint32_t Server_CookieManager_VisitAllCookies_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_CookieManager_VisitUrlCookies_args::~Server_CookieManager_VisitUrlCookies_args() noexcept {
}


uint32_t Server_CookieManager_VisitUrlCookies_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cookieManager.read(iprot);
          this->__isset.cookieManager = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->visitor.read(iprot);
          this->__isset.visitor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          this->__isset.url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeHttpOnly);
          this->__isset.includeHttpOnly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_CookieManager_VisitUrlCookies_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_CookieManager_VisitUrlCookies_args");

  xfer += oprot->writeFieldBegin("cookieManager", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->cookieManager.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("visitor", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->visitor.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("includeHttpOnly", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->includeHttpOnly);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_CookieManager_VisitUrlCookies_pargs::~Server_CookieManager_VisitUrlCookies_pargs() noexcept {
}


uint32_t Server_CookieManager_VisitUrlCookies_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_CookieManager_VisitUrlCookies_pargs");

  xfer += oprot->writeFieldBegin("cookieManager", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->cookieManager)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("visitor", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->visitor)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->url)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("includeHttpOnly", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool((*(this->includeHttpOnly)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_CookieManager_VisitUrlCookies_result::~Server_CookieManager_VisitUrlCookies_result() noexcept {
}


uint32_t Server_CookieManager_VisitUrlCookies_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_CookieManager_VisitUrlCookies_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_CookieManager_VisitUrlCookies_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_CookieManager_VisitUrlCookies_presult::~Server_CookieManager_VisitUrlCookies_presult() noexcept {
}


uint32_t Server_CookieManager_VisitUrlCookies_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_CookieManager_SetCookie_args::~Server_CookieManager_SetCookie_args() noexcept {
}


uint32_t Server_CookieManager_SetCookie_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cookieManager.read(iprot);
          this->__isset.cookieManager = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          this->__isset.url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cookie.read(iprot);
          this->__isset.cookie = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_CookieManager_SetCookie_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_CookieManager_SetCookie_args");

  xfer += oprot->writeFieldBegin("cookieManager", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->cookieManager.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cookie", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->cookie.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_CookieManager_SetCookie_pargs::~Server_CookieManager_SetCookie_pargs() noexcept {
}


uint32_t Server_CookieManager_SetCookie_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_CookieManager_SetCookie_pargs");

  xfer += oprot->writeFieldBegin("cookieManager", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->cookieManager)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->url)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cookie", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->cookie)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_CookieManager_SetCookie_result::~Server_CookieManager_SetCookie_result() noexcept {
}


uint32_t Server_CookieManager_SetCookie_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_CookieManager_SetCookie_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_CookieManager_SetCookie_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_CookieManager_SetCookie_presult::~Server_CookieManager_SetCookie_presult() noexcept {
}


uint32_t Server_CookieManager_SetCookie_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_CookieManager_DeleteCookies_args::~Server_CookieManager_DeleteCookies_args() noexcept {
}


uint32_t Server_CookieManager_DeleteCookies_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cookieManager.read(iprot);
          this->__isset.cookieManager = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          this->__isset.url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cookieName);
          this->__isset.cookieName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_CookieManager_DeleteCookies_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_CookieManager_DeleteCookies_args");

  xfer += oprot->writeFieldBegin("cookieManager", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->cookieManager.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cookieName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->cookieName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_CookieManager_DeleteCookies_pargs::~Server_CookieManager_DeleteCookies_pargs() noexcept {
}


uint32_t Server_CookieManager_DeleteCookies_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_CookieManager_DeleteCookies_pargs");

  xfer += oprot->writeFieldBegin("cookieManager", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->cookieManager)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->url)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cookieName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->cookieName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_CookieManager_DeleteCookies_result::~Server_CookieManager_DeleteCookies_result() noexcept {
}


uint32_t Server_CookieManager_DeleteCookies_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_CookieManager_DeleteCookies_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_CookieManager_DeleteCookies_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_CookieManager_DeleteCookies_presult::~Server_CookieManager_DeleteCookies_presult() noexcept {
}


uint32_t Server_CookieManager_DeleteCookies_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_CookieManager_FlushStore_args::~Server_CookieManager_FlushStore_args() noexcept {
}


uint32_t Server_CookieManager_FlushStore_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cookieManager.read(iprot);
          this->__isset.cookieManager = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->completionCallback.read(iprot);
          this->__isset.completionCallback = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_CookieManager_FlushStore_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_CookieManager_FlushStore_args");

  xfer += oprot->writeFieldBegin("cookieManager", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->cookieManager.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("completionCallback", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->completionCallback.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_CookieManager_FlushStore_pargs::~Server_CookieManager_FlushStore_pargs() noexcept {
}


uint32_t Server_CookieManager_FlushStore_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_CookieManager_FlushStore_pargs");

  xfer += oprot->writeFieldBegin("cookieManager", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->cookieManager)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("completionCallback", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->completionCallback)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_CookieManager_FlushStore_result::~Server_CookieManager_FlushStore_result() noexcept {
}


uint32_t Server_CookieManager_FlushStore_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_CookieManager_FlushStore_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_CookieManager_FlushStore_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_CookieManager_FlushStore_presult::~Server_CookieManager_FlushStore_presult() noexcept {
}


uint32_t Server_CookieManager_FlushStore_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

int32_t ServerClient::connect(const std::string& backwardConnectionPipe, const bool isMaster)
{
  send_connect(backwardConnectionPipe, isMaster);
  return recv_connect();
}

void ServerClient::send_connect(const std::string& backwardConnectionPipe, const bool isMaster)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("connect", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_connect_pargs args;
  args.backwardConnectionPipe = &backwardConnectionPipe;
  args.isMaster = &isMaster;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t ServerClient::recv_connect()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("connect") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  Server_connect_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "connect failed: unknown result");
}

int32_t ServerClient::connectTcp(const int32_t backwardConnectionPort, const bool isMaster)
{
  send_connectTcp(backwardConnectionPort, isMaster);
  return recv_connectTcp();
}

void ServerClient::send_connectTcp(const int32_t backwardConnectionPort, const bool isMaster)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("connectTcp", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_connectTcp_pargs args;
  args.backwardConnectionPort = &backwardConnectionPort;
  args.isMaster = &isMaster;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t ServerClient::recv_connectTcp()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("connectTcp") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  Server_connectTcp_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "connectTcp failed: unknown result");
}

void ServerClient::log(const std::string& msg)
{
  send_log(msg);
}

void ServerClient::send_log(const std::string& msg)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("log", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_log_pargs args;
  args.msg = &msg;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::echo(std::string& _return, const std::string& msg)
{
  send_echo(msg);
  recv_echo(_return);
}

void ServerClient::send_echo(const std::string& msg)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("echo", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_echo_pargs args;
  args.msg = &msg;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_echo(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("echo") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_echo_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "echo failed: unknown result");
}

void ServerClient::version(std::string& _return)
{
  send_version();
  recv_version(_return);
}

void ServerClient::send_version()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("version", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_version_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_version(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("version") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_version_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "version failed: unknown result");
}

void ServerClient::state(std::string& _return)
{
  send_state();
  recv_state(_return);
}

void ServerClient::send_state()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("state", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_state_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_state(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("state") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_state_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "state failed: unknown result");
}

void ServerClient::stop()
{
  send_stop();
}

void ServerClient::send_stop()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("stop", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_stop_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t ServerClient::Browser_Create(const int32_t cid, const int32_t handlersMask, const  ::thrift_codegen::RObject& requestContextHandler)
{
  send_Browser_Create(cid, handlersMask, requestContextHandler);
  return recv_Browser_Create();
}

void ServerClient::send_Browser_Create(const int32_t cid, const int32_t handlersMask, const  ::thrift_codegen::RObject& requestContextHandler)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_Create", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_Create_pargs args;
  args.cid = &cid;
  args.handlersMask = &handlersMask;
  args.requestContextHandler = &requestContextHandler;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t ServerClient::recv_Browser_Create()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Browser_Create") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  Server_Browser_Create_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_Create failed: unknown result");
}

void ServerClient::Browser_StartNativeCreation(const int32_t bid, const std::string& url)
{
  send_Browser_StartNativeCreation(bid, url);
}

void ServerClient::send_Browser_StartNativeCreation(const int32_t bid, const std::string& url)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_StartNativeCreation", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_StartNativeCreation_pargs args;
  args.bid = &bid;
  args.url = &url;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Browser_Close(const int32_t bid)
{
  send_Browser_Close(bid);
}

void ServerClient::send_Browser_Close(const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_Close", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_Close_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Browser_Reload(const int32_t bid)
{
  send_Browser_Reload(bid);
}

void ServerClient::send_Browser_Reload(const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_Reload", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_Reload_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Browser_ReloadIgnoreCache(const int32_t bid)
{
  send_Browser_ReloadIgnoreCache(bid);
}

void ServerClient::send_Browser_ReloadIgnoreCache(const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_ReloadIgnoreCache", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_ReloadIgnoreCache_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Browser_LoadURL(const int32_t bid, const std::string& url)
{
  send_Browser_LoadURL(bid, url);
}

void ServerClient::send_Browser_LoadURL(const int32_t bid, const std::string& url)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_LoadURL", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_LoadURL_pargs args;
  args.bid = &bid;
  args.url = &url;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Browser_LoadRequest(const int32_t bid, const  ::thrift_codegen::RObject& request)
{
  send_Browser_LoadRequest(bid, request);
}

void ServerClient::send_Browser_LoadRequest(const int32_t bid, const  ::thrift_codegen::RObject& request)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_LoadRequest", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_LoadRequest_pargs args;
  args.bid = &bid;
  args.request = &request;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Browser_GetURL(std::string& _return, const int32_t bid)
{
  send_Browser_GetURL(bid);
  recv_Browser_GetURL(_return);
}

void ServerClient::send_Browser_GetURL(const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_GetURL", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_GetURL_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Browser_GetURL(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Browser_GetURL") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Browser_GetURL_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_GetURL failed: unknown result");
}

void ServerClient::Browser_ExecuteJavaScript(const int32_t bid, const std::string& code, const std::string& url, const int32_t line)
{
  send_Browser_ExecuteJavaScript(bid, code, url, line);
}

void ServerClient::send_Browser_ExecuteJavaScript(const int32_t bid, const std::string& code, const std::string& url, const int32_t line)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_ExecuteJavaScript", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_ExecuteJavaScript_pargs args;
  args.bid = &bid;
  args.code = &code;
  args.url = &url;
  args.line = &line;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Browser_WasResized(const int32_t bid)
{
  send_Browser_WasResized(bid);
}

void ServerClient::send_Browser_WasResized(const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_WasResized", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_WasResized_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Browser_NotifyScreenInfoChanged(const int32_t bid)
{
  send_Browser_NotifyScreenInfoChanged(bid);
}

void ServerClient::send_Browser_NotifyScreenInfoChanged(const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_NotifyScreenInfoChanged", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_NotifyScreenInfoChanged_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Browser_SendKeyEvent(const int32_t bid, const int32_t event_type, const int32_t modifiers, const int16_t key_char, const int64_t scanCode, const int32_t key_code)
{
  send_Browser_SendKeyEvent(bid, event_type, modifiers, key_char, scanCode, key_code);
}

void ServerClient::send_Browser_SendKeyEvent(const int32_t bid, const int32_t event_type, const int32_t modifiers, const int16_t key_char, const int64_t scanCode, const int32_t key_code)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_SendKeyEvent", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_SendKeyEvent_pargs args;
  args.bid = &bid;
  args.event_type = &event_type;
  args.modifiers = &modifiers;
  args.key_char = &key_char;
  args.scanCode = &scanCode;
  args.key_code = &key_code;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Browser_SendMouseEvent(const int32_t bid, const int32_t event_type, const int32_t x, const int32_t y, const int32_t modifiers, const int32_t click_count, const int32_t button)
{
  send_Browser_SendMouseEvent(bid, event_type, x, y, modifiers, click_count, button);
}

void ServerClient::send_Browser_SendMouseEvent(const int32_t bid, const int32_t event_type, const int32_t x, const int32_t y, const int32_t modifiers, const int32_t click_count, const int32_t button)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_SendMouseEvent", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_SendMouseEvent_pargs args;
  args.bid = &bid;
  args.event_type = &event_type;
  args.x = &x;
  args.y = &y;
  args.modifiers = &modifiers;
  args.click_count = &click_count;
  args.button = &button;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Browser_SendMouseWheelEvent(const int32_t bid, const int32_t scroll_type, const int32_t x, const int32_t y, const int32_t modifiers, const int32_t delta, const int32_t units_to_scroll)
{
  send_Browser_SendMouseWheelEvent(bid, scroll_type, x, y, modifiers, delta, units_to_scroll);
}

void ServerClient::send_Browser_SendMouseWheelEvent(const int32_t bid, const int32_t scroll_type, const int32_t x, const int32_t y, const int32_t modifiers, const int32_t delta, const int32_t units_to_scroll)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_SendMouseWheelEvent", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_SendMouseWheelEvent_pargs args;
  args.bid = &bid;
  args.scroll_type = &scroll_type;
  args.x = &x;
  args.y = &y;
  args.modifiers = &modifiers;
  args.delta = &delta;
  args.units_to_scroll = &units_to_scroll;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ServerClient::Browser_CanGoForward(const int32_t bid)
{
  send_Browser_CanGoForward(bid);
  return recv_Browser_CanGoForward();
}

void ServerClient::send_Browser_CanGoForward(const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_CanGoForward", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_CanGoForward_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ServerClient::recv_Browser_CanGoForward()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Browser_CanGoForward") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  Server_Browser_CanGoForward_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_CanGoForward failed: unknown result");
}

bool ServerClient::Browser_CanGoBack(const int32_t bid)
{
  send_Browser_CanGoBack(bid);
  return recv_Browser_CanGoBack();
}

void ServerClient::send_Browser_CanGoBack(const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_CanGoBack", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_CanGoBack_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ServerClient::recv_Browser_CanGoBack()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Browser_CanGoBack") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  Server_Browser_CanGoBack_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_CanGoBack failed: unknown result");
}

void ServerClient::Browser_GoBack(const int32_t bid)
{
  send_Browser_GoBack(bid);
}

void ServerClient::send_Browser_GoBack(const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_GoBack", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_GoBack_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Browser_GoForward(const int32_t bid)
{
  send_Browser_GoForward(bid);
}

void ServerClient::send_Browser_GoForward(const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_GoForward", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_GoForward_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ServerClient::Browser_IsLoading(const int32_t bid)
{
  send_Browser_IsLoading(bid);
  return recv_Browser_IsLoading();
}

void ServerClient::send_Browser_IsLoading(const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_IsLoading", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_IsLoading_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ServerClient::recv_Browser_IsLoading()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Browser_IsLoading") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  Server_Browser_IsLoading_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_IsLoading failed: unknown result");
}

void ServerClient::Browser_StopLoad(const int32_t bid)
{
  send_Browser_StopLoad(bid);
}

void ServerClient::send_Browser_StopLoad(const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_StopLoad", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_StopLoad_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Browser_GetMainFrame( ::thrift_codegen::RObject& _return, const int32_t bid)
{
  send_Browser_GetMainFrame(bid);
  recv_Browser_GetMainFrame(_return);
}

void ServerClient::send_Browser_GetMainFrame(const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_GetMainFrame", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_GetMainFrame_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Browser_GetMainFrame( ::thrift_codegen::RObject& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Browser_GetMainFrame") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Browser_GetMainFrame_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_GetMainFrame failed: unknown result");
}

void ServerClient::Browser_GetFocusedFrame( ::thrift_codegen::RObject& _return, const int32_t bid)
{
  send_Browser_GetFocusedFrame(bid);
  recv_Browser_GetFocusedFrame(_return);
}

void ServerClient::send_Browser_GetFocusedFrame(const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_GetFocusedFrame", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_GetFocusedFrame_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Browser_GetFocusedFrame( ::thrift_codegen::RObject& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Browser_GetFocusedFrame") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Browser_GetFocusedFrame_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_GetFocusedFrame failed: unknown result");
}

void ServerClient::Browser_GetFrameByIdentifier( ::thrift_codegen::RObject& _return, const int32_t bid, const std::string& identifier)
{
  send_Browser_GetFrameByIdentifier(bid, identifier);
  recv_Browser_GetFrameByIdentifier(_return);
}

void ServerClient::send_Browser_GetFrameByIdentifier(const int32_t bid, const std::string& identifier)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_GetFrameByIdentifier", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_GetFrameByIdentifier_pargs args;
  args.bid = &bid;
  args.identifier = &identifier;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Browser_GetFrameByIdentifier( ::thrift_codegen::RObject& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Browser_GetFrameByIdentifier") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Browser_GetFrameByIdentifier_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_GetFrameByIdentifier failed: unknown result");
}

void ServerClient::Browser_GetFrameByName( ::thrift_codegen::RObject& _return, const int32_t bid, const std::string& name)
{
  send_Browser_GetFrameByName(bid, name);
  recv_Browser_GetFrameByName(_return);
}

void ServerClient::send_Browser_GetFrameByName(const int32_t bid, const std::string& name)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_GetFrameByName", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_GetFrameByName_pargs args;
  args.bid = &bid;
  args.name = &name;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Browser_GetFrameByName( ::thrift_codegen::RObject& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Browser_GetFrameByName") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Browser_GetFrameByName_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_GetFrameByName failed: unknown result");
}

int32_t ServerClient::Browser_GetFrameCount(const int32_t bid)
{
  send_Browser_GetFrameCount(bid);
  return recv_Browser_GetFrameCount();
}

void ServerClient::send_Browser_GetFrameCount(const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_GetFrameCount", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_GetFrameCount_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t ServerClient::recv_Browser_GetFrameCount()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Browser_GetFrameCount") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  Server_Browser_GetFrameCount_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_GetFrameCount failed: unknown result");
}

void ServerClient::Browser_GetFrameIdentifiers(std::vector<std::string> & _return, const int32_t bid)
{
  send_Browser_GetFrameIdentifiers(bid);
  recv_Browser_GetFrameIdentifiers(_return);
}

void ServerClient::send_Browser_GetFrameIdentifiers(const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_GetFrameIdentifiers", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_GetFrameIdentifiers_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Browser_GetFrameIdentifiers(std::vector<std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Browser_GetFrameIdentifiers") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Browser_GetFrameIdentifiers_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_GetFrameIdentifiers failed: unknown result");
}

void ServerClient::Browser_GetFrameNames(std::vector<std::string> & _return, const int32_t bid)
{
  send_Browser_GetFrameNames(bid);
  recv_Browser_GetFrameNames(_return);
}

void ServerClient::send_Browser_GetFrameNames(const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_GetFrameNames", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_GetFrameNames_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Browser_GetFrameNames(std::vector<std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Browser_GetFrameNames") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Browser_GetFrameNames_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_GetFrameNames failed: unknown result");
}

bool ServerClient::Browser_IsPopup(const int32_t bid)
{
  send_Browser_IsPopup(bid);
  return recv_Browser_IsPopup();
}

void ServerClient::send_Browser_IsPopup(const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_IsPopup", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_IsPopup_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ServerClient::recv_Browser_IsPopup()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Browser_IsPopup") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  Server_Browser_IsPopup_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_IsPopup failed: unknown result");
}

bool ServerClient::Browser_HasDocument(const int32_t bid)
{
  send_Browser_HasDocument(bid);
  return recv_Browser_HasDocument();
}

void ServerClient::send_Browser_HasDocument(const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_HasDocument", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_HasDocument_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ServerClient::recv_Browser_HasDocument()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Browser_HasDocument") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  Server_Browser_HasDocument_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_HasDocument failed: unknown result");
}

void ServerClient::Browser_ViewSource(const int32_t bid)
{
  send_Browser_ViewSource(bid);
}

void ServerClient::send_Browser_ViewSource(const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_ViewSource", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_ViewSource_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Browser_GetSource(const int32_t bid, const  ::thrift_codegen::RObject& stringVisitor)
{
  send_Browser_GetSource(bid, stringVisitor);
}

void ServerClient::send_Browser_GetSource(const int32_t bid, const  ::thrift_codegen::RObject& stringVisitor)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_GetSource", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_GetSource_pargs args;
  args.bid = &bid;
  args.stringVisitor = &stringVisitor;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Browser_GetText(const int32_t bid, const  ::thrift_codegen::RObject& stringVisitor)
{
  send_Browser_GetText(bid, stringVisitor);
}

void ServerClient::send_Browser_GetText(const int32_t bid, const  ::thrift_codegen::RObject& stringVisitor)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_GetText", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_GetText_pargs args;
  args.bid = &bid;
  args.stringVisitor = &stringVisitor;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Browser_SetFocus(const int32_t bid, const bool enable)
{
  send_Browser_SetFocus(bid, enable);
}

void ServerClient::send_Browser_SetFocus(const int32_t bid, const bool enable)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_SetFocus", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_SetFocus_pargs args;
  args.bid = &bid;
  args.enable = &enable;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

double ServerClient::Browser_GetZoomLevel(const int32_t bid)
{
  send_Browser_GetZoomLevel(bid);
  return recv_Browser_GetZoomLevel();
}

void ServerClient::send_Browser_GetZoomLevel(const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_GetZoomLevel", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_GetZoomLevel_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

double ServerClient::recv_Browser_GetZoomLevel()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Browser_GetZoomLevel") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  double _return;
  Server_Browser_GetZoomLevel_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_GetZoomLevel failed: unknown result");
}

void ServerClient::Browser_SetZoomLevel(const int32_t bid, const double val)
{
  send_Browser_SetZoomLevel(bid, val);
}

void ServerClient::send_Browser_SetZoomLevel(const int32_t bid, const double val)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_SetZoomLevel", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_SetZoomLevel_pargs args;
  args.bid = &bid;
  args.val = &val;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Browser_StartDownload(const int32_t bid, const std::string& url)
{
  send_Browser_StartDownload(bid, url);
}

void ServerClient::send_Browser_StartDownload(const int32_t bid, const std::string& url)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_StartDownload", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_StartDownload_pargs args;
  args.bid = &bid;
  args.url = &url;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Browser_Find(const int32_t bid, const std::string& searchText, const bool forward, const bool matchCase, const bool findNext)
{
  send_Browser_Find(bid, searchText, forward, matchCase, findNext);
}

void ServerClient::send_Browser_Find(const int32_t bid, const std::string& searchText, const bool forward, const bool matchCase, const bool findNext)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_Find", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_Find_pargs args;
  args.bid = &bid;
  args.searchText = &searchText;
  args.forward = &forward;
  args.matchCase = &matchCase;
  args.findNext = &findNext;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Browser_StopFinding(const int32_t bid, const bool clearSelection)
{
  send_Browser_StopFinding(bid, clearSelection);
}

void ServerClient::send_Browser_StopFinding(const int32_t bid, const bool clearSelection)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_StopFinding", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_StopFinding_pargs args;
  args.bid = &bid;
  args.clearSelection = &clearSelection;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Browser_ReplaceMisspelling(const int32_t bid, const std::string& word)
{
  send_Browser_ReplaceMisspelling(bid, word);
}

void ServerClient::send_Browser_ReplaceMisspelling(const int32_t bid, const std::string& word)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_ReplaceMisspelling", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_ReplaceMisspelling_pargs args;
  args.bid = &bid;
  args.word = &word;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Browser_SetFrameRate(const int32_t bid, const int32_t val)
{
  send_Browser_SetFrameRate(bid, val);
}

void ServerClient::send_Browser_SetFrameRate(const int32_t bid, const int32_t val)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_SetFrameRate", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_SetFrameRate_pargs args;
  args.bid = &bid;
  args.val = &val;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Frame_ExecuteJavaScript(const int32_t frameId, const std::string& code, const std::string& url, const int32_t line)
{
  send_Frame_ExecuteJavaScript(frameId, code, url, line);
}

void ServerClient::send_Frame_ExecuteJavaScript(const int32_t frameId, const std::string& code, const std::string& url, const int32_t line)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Frame_ExecuteJavaScript", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Frame_ExecuteJavaScript_pargs args;
  args.frameId = &frameId;
  args.code = &code;
  args.url = &url;
  args.line = &line;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Frame_Dispose(const int32_t frameId)
{
  send_Frame_Dispose(frameId);
}

void ServerClient::send_Frame_Dispose(const int32_t frameId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Frame_Dispose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Frame_Dispose_pargs args;
  args.frameId = &frameId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Frame_GetParent( ::thrift_codegen::RObject& _return, const int32_t frameId)
{
  send_Frame_GetParent(frameId);
  recv_Frame_GetParent(_return);
}

void ServerClient::send_Frame_GetParent(const int32_t frameId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Frame_GetParent", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Frame_GetParent_pargs args;
  args.frameId = &frameId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Frame_GetParent( ::thrift_codegen::RObject& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Frame_GetParent") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Frame_GetParent_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Frame_GetParent failed: unknown result");
}

void ServerClient::Frame_Undo(const int32_t frameId)
{
  send_Frame_Undo(frameId);
}

void ServerClient::send_Frame_Undo(const int32_t frameId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Frame_Undo", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Frame_Undo_pargs args;
  args.frameId = &frameId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Frame_Redo(const int32_t frameId)
{
  send_Frame_Redo(frameId);
}

void ServerClient::send_Frame_Redo(const int32_t frameId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Frame_Redo", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Frame_Redo_pargs args;
  args.frameId = &frameId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Frame_Cut(const int32_t frameId)
{
  send_Frame_Cut(frameId);
}

void ServerClient::send_Frame_Cut(const int32_t frameId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Frame_Cut", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Frame_Cut_pargs args;
  args.frameId = &frameId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Frame_Copy(const int32_t frameId)
{
  send_Frame_Copy(frameId);
}

void ServerClient::send_Frame_Copy(const int32_t frameId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Frame_Copy", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Frame_Copy_pargs args;
  args.frameId = &frameId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Frame_Paste(const int32_t frameId)
{
  send_Frame_Paste(frameId);
}

void ServerClient::send_Frame_Paste(const int32_t frameId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Frame_Paste", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Frame_Paste_pargs args;
  args.frameId = &frameId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Frame_Delete(const int32_t frameId)
{
  send_Frame_Delete(frameId);
}

void ServerClient::send_Frame_Delete(const int32_t frameId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Frame_Delete", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Frame_Delete_pargs args;
  args.frameId = &frameId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Frame_SelectAll(const int32_t frameId)
{
  send_Frame_SelectAll(frameId);
}

void ServerClient::send_Frame_SelectAll(const int32_t frameId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Frame_SelectAll", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Frame_SelectAll_pargs args;
  args.frameId = &frameId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Request_Create( ::thrift_codegen::RObject& _return)
{
  send_Request_Create();
  recv_Request_Create(_return);
}

void ServerClient::send_Request_Create()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Request_Create", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_Create_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Request_Create( ::thrift_codegen::RObject& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Request_Create") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Request_Create_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Request_Create failed: unknown result");
}

void ServerClient::Request_Dispose(const int32_t requestId)
{
  send_Request_Dispose(requestId);
}

void ServerClient::send_Request_Dispose(const int32_t requestId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Request_Dispose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Request_Dispose_pargs args;
  args.requestId = &requestId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Request_Update(const  ::thrift_codegen::RObject& request)
{
  send_Request_Update(request);
  recv_Request_Update();
}

void ServerClient::send_Request_Update(const  ::thrift_codegen::RObject& request)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Request_Update", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_Update_pargs args;
  args.request = &request;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Request_Update()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Request_Update") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Request_Update_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void ServerClient::Request_GetPostData( ::thrift_codegen::PostData& _return, const  ::thrift_codegen::RObject& request)
{
  send_Request_GetPostData(request);
  recv_Request_GetPostData(_return);
}

void ServerClient::send_Request_GetPostData(const  ::thrift_codegen::RObject& request)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Request_GetPostData", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_GetPostData_pargs args;
  args.request = &request;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Request_GetPostData( ::thrift_codegen::PostData& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Request_GetPostData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Request_GetPostData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Request_GetPostData failed: unknown result");
}

void ServerClient::Request_SetPostData(const  ::thrift_codegen::RObject& request, const  ::thrift_codegen::PostData& postData)
{
  send_Request_SetPostData(request, postData);
  recv_Request_SetPostData();
}

void ServerClient::send_Request_SetPostData(const  ::thrift_codegen::RObject& request, const  ::thrift_codegen::PostData& postData)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Request_SetPostData", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_SetPostData_pargs args;
  args.request = &request;
  args.postData = &postData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Request_SetPostData()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Request_SetPostData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Request_SetPostData_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void ServerClient::Request_GetHeaderByName(std::string& _return, const  ::thrift_codegen::RObject& request, const std::string& name)
{
  send_Request_GetHeaderByName(request, name);
  recv_Request_GetHeaderByName(_return);
}

void ServerClient::send_Request_GetHeaderByName(const  ::thrift_codegen::RObject& request, const std::string& name)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Request_GetHeaderByName", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_GetHeaderByName_pargs args;
  args.request = &request;
  args.name = &name;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Request_GetHeaderByName(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Request_GetHeaderByName") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Request_GetHeaderByName_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Request_GetHeaderByName failed: unknown result");
}

void ServerClient::Request_SetHeaderByName(const  ::thrift_codegen::RObject& request, const std::string& name, const std::string& value, const bool overwrite)
{
  send_Request_SetHeaderByName(request, name, value, overwrite);
  recv_Request_SetHeaderByName();
}

void ServerClient::send_Request_SetHeaderByName(const  ::thrift_codegen::RObject& request, const std::string& name, const std::string& value, const bool overwrite)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Request_SetHeaderByName", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_SetHeaderByName_pargs args;
  args.request = &request;
  args.name = &name;
  args.value = &value;
  args.overwrite = &overwrite;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Request_SetHeaderByName()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Request_SetHeaderByName") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Request_SetHeaderByName_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void ServerClient::Request_GetHeaderMap(std::map<std::string, std::string> & _return, const  ::thrift_codegen::RObject& request)
{
  send_Request_GetHeaderMap(request);
  recv_Request_GetHeaderMap(_return);
}

void ServerClient::send_Request_GetHeaderMap(const  ::thrift_codegen::RObject& request)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Request_GetHeaderMap", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_GetHeaderMap_pargs args;
  args.request = &request;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Request_GetHeaderMap(std::map<std::string, std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Request_GetHeaderMap") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Request_GetHeaderMap_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Request_GetHeaderMap failed: unknown result");
}

void ServerClient::Request_SetHeaderMap(const  ::thrift_codegen::RObject& request, const std::map<std::string, std::string> & headerMap)
{
  send_Request_SetHeaderMap(request, headerMap);
  recv_Request_SetHeaderMap();
}

void ServerClient::send_Request_SetHeaderMap(const  ::thrift_codegen::RObject& request, const std::map<std::string, std::string> & headerMap)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Request_SetHeaderMap", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_SetHeaderMap_pargs args;
  args.request = &request;
  args.headerMap = &headerMap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Request_SetHeaderMap()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Request_SetHeaderMap") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Request_SetHeaderMap_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void ServerClient::Request_Set(const  ::thrift_codegen::RObject& request, const std::string& url, const std::string& method, const  ::thrift_codegen::PostData& postData, const std::map<std::string, std::string> & headerMap)
{
  send_Request_Set(request, url, method, postData, headerMap);
  recv_Request_Set();
}

void ServerClient::send_Request_Set(const  ::thrift_codegen::RObject& request, const std::string& url, const std::string& method, const  ::thrift_codegen::PostData& postData, const std::map<std::string, std::string> & headerMap)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Request_Set", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_Set_pargs args;
  args.request = &request;
  args.url = &url;
  args.method = &method;
  args.postData = &postData;
  args.headerMap = &headerMap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Request_Set()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Request_Set") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Request_Set_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void ServerClient::Response_Update(const  ::thrift_codegen::RObject& response)
{
  send_Response_Update(response);
  recv_Response_Update();
}

void ServerClient::send_Response_Update(const  ::thrift_codegen::RObject& response)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Response_Update", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Response_Update_pargs args;
  args.response = &response;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Response_Update()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Response_Update") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Response_Update_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void ServerClient::Response_GetHeaderByName(std::string& _return, const  ::thrift_codegen::RObject& response, const std::string& name)
{
  send_Response_GetHeaderByName(response, name);
  recv_Response_GetHeaderByName(_return);
}

void ServerClient::send_Response_GetHeaderByName(const  ::thrift_codegen::RObject& response, const std::string& name)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Response_GetHeaderByName", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Response_GetHeaderByName_pargs args;
  args.response = &response;
  args.name = &name;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Response_GetHeaderByName(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Response_GetHeaderByName") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Response_GetHeaderByName_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Response_GetHeaderByName failed: unknown result");
}

void ServerClient::Response_SetHeaderByName(const  ::thrift_codegen::RObject& response, const std::string& name, const std::string& value, const bool overwrite)
{
  send_Response_SetHeaderByName(response, name, value, overwrite);
  recv_Response_SetHeaderByName();
}

void ServerClient::send_Response_SetHeaderByName(const  ::thrift_codegen::RObject& response, const std::string& name, const std::string& value, const bool overwrite)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Response_SetHeaderByName", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Response_SetHeaderByName_pargs args;
  args.response = &response;
  args.name = &name;
  args.value = &value;
  args.overwrite = &overwrite;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Response_SetHeaderByName()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Response_SetHeaderByName") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Response_SetHeaderByName_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void ServerClient::Response_GetHeaderMap(std::map<std::string, std::string> & _return, const  ::thrift_codegen::RObject& response)
{
  send_Response_GetHeaderMap(response);
  recv_Response_GetHeaderMap(_return);
}

void ServerClient::send_Response_GetHeaderMap(const  ::thrift_codegen::RObject& response)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Response_GetHeaderMap", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Response_GetHeaderMap_pargs args;
  args.response = &response;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Response_GetHeaderMap(std::map<std::string, std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Response_GetHeaderMap") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Response_GetHeaderMap_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Response_GetHeaderMap failed: unknown result");
}

void ServerClient::Response_SetHeaderMap(const  ::thrift_codegen::RObject& response, const std::map<std::string, std::string> & headerMap)
{
  send_Response_SetHeaderMap(response, headerMap);
  recv_Response_SetHeaderMap();
}

void ServerClient::send_Response_SetHeaderMap(const  ::thrift_codegen::RObject& response, const std::map<std::string, std::string> & headerMap)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Response_SetHeaderMap", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Response_SetHeaderMap_pargs args;
  args.response = &response;
  args.headerMap = &headerMap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Response_SetHeaderMap()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Response_SetHeaderMap") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Response_SetHeaderMap_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void ServerClient::Callback_Dispose(const  ::thrift_codegen::RObject& callback)
{
  send_Callback_Dispose(callback);
}

void ServerClient::send_Callback_Dispose(const  ::thrift_codegen::RObject& callback)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Callback_Dispose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Callback_Dispose_pargs args;
  args.callback = &callback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Callback_Continue(const  ::thrift_codegen::RObject& callback)
{
  send_Callback_Continue(callback);
}

void ServerClient::send_Callback_Continue(const  ::thrift_codegen::RObject& callback)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Callback_Continue", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Callback_Continue_pargs args;
  args.callback = &callback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Callback_Cancel(const  ::thrift_codegen::RObject& callback)
{
  send_Callback_Cancel(callback);
}

void ServerClient::send_Callback_Cancel(const  ::thrift_codegen::RObject& callback)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Callback_Cancel", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Callback_Cancel_pargs args;
  args.callback = &callback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::AuthCallback_Dispose(const  ::thrift_codegen::RObject& authCallback)
{
  send_AuthCallback_Dispose(authCallback);
}

void ServerClient::send_AuthCallback_Dispose(const  ::thrift_codegen::RObject& authCallback)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("AuthCallback_Dispose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_AuthCallback_Dispose_pargs args;
  args.authCallback = &authCallback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::AuthCallback_Continue(const  ::thrift_codegen::RObject& authCallback, const std::string& username, const std::string& password)
{
  send_AuthCallback_Continue(authCallback, username, password);
}

void ServerClient::send_AuthCallback_Continue(const  ::thrift_codegen::RObject& authCallback, const std::string& username, const std::string& password)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("AuthCallback_Continue", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_AuthCallback_Continue_pargs args;
  args.authCallback = &authCallback;
  args.username = &username;
  args.password = &password;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::AuthCallback_Cancel(const  ::thrift_codegen::RObject& authCallback)
{
  send_AuthCallback_Cancel(authCallback);
}

void ServerClient::send_AuthCallback_Cancel(const  ::thrift_codegen::RObject& authCallback)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("AuthCallback_Cancel", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_AuthCallback_Cancel_pargs args;
  args.authCallback = &authCallback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::MessageRouter_Create( ::thrift_codegen::RObject& _return, const std::string& query, const std::string& cancel)
{
  send_MessageRouter_Create(query, cancel);
  recv_MessageRouter_Create(_return);
}

void ServerClient::send_MessageRouter_Create(const std::string& query, const std::string& cancel)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("MessageRouter_Create", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_MessageRouter_Create_pargs args;
  args.query = &query;
  args.cancel = &cancel;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_MessageRouter_Create( ::thrift_codegen::RObject& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("MessageRouter_Create") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_MessageRouter_Create_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "MessageRouter_Create failed: unknown result");
}

void ServerClient::MessageRouter_Dispose(const  ::thrift_codegen::RObject& msgRouter)
{
  send_MessageRouter_Dispose(msgRouter);
}

void ServerClient::send_MessageRouter_Dispose(const  ::thrift_codegen::RObject& msgRouter)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("MessageRouter_Dispose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_MessageRouter_Dispose_pargs args;
  args.msgRouter = &msgRouter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::MessageRouter_AddMessageRouterToBrowser(const  ::thrift_codegen::RObject& msgRouter, const int32_t bid)
{
  send_MessageRouter_AddMessageRouterToBrowser(msgRouter, bid);
  recv_MessageRouter_AddMessageRouterToBrowser();
}

void ServerClient::send_MessageRouter_AddMessageRouterToBrowser(const  ::thrift_codegen::RObject& msgRouter, const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("MessageRouter_AddMessageRouterToBrowser", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_MessageRouter_AddMessageRouterToBrowser_pargs args;
  args.msgRouter = &msgRouter;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_MessageRouter_AddMessageRouterToBrowser()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("MessageRouter_AddMessageRouterToBrowser") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_MessageRouter_AddMessageRouterToBrowser_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void ServerClient::MessageRouter_RemoveMessageRouterFromBrowser(const  ::thrift_codegen::RObject& msgRouter, const int32_t bid)
{
  send_MessageRouter_RemoveMessageRouterFromBrowser(msgRouter, bid);
  recv_MessageRouter_RemoveMessageRouterFromBrowser();
}

void ServerClient::send_MessageRouter_RemoveMessageRouterFromBrowser(const  ::thrift_codegen::RObject& msgRouter, const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("MessageRouter_RemoveMessageRouterFromBrowser", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_MessageRouter_RemoveMessageRouterFromBrowser_pargs args;
  args.msgRouter = &msgRouter;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_MessageRouter_RemoveMessageRouterFromBrowser()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("MessageRouter_RemoveMessageRouterFromBrowser") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_MessageRouter_RemoveMessageRouterFromBrowser_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void ServerClient::MessageRouter_AddHandler(const  ::thrift_codegen::RObject& msgRouter, const  ::thrift_codegen::RObject& handler, const bool first)
{
  send_MessageRouter_AddHandler(msgRouter, handler, first);
  recv_MessageRouter_AddHandler();
}

void ServerClient::send_MessageRouter_AddHandler(const  ::thrift_codegen::RObject& msgRouter, const  ::thrift_codegen::RObject& handler, const bool first)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("MessageRouter_AddHandler", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_MessageRouter_AddHandler_pargs args;
  args.msgRouter = &msgRouter;
  args.handler = &handler;
  args.first = &first;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_MessageRouter_AddHandler()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("MessageRouter_AddHandler") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_MessageRouter_AddHandler_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void ServerClient::MessageRouter_RemoveHandler(const  ::thrift_codegen::RObject& msgRouter, const  ::thrift_codegen::RObject& handler)
{
  send_MessageRouter_RemoveHandler(msgRouter, handler);
  recv_MessageRouter_RemoveHandler();
}

void ServerClient::send_MessageRouter_RemoveHandler(const  ::thrift_codegen::RObject& msgRouter, const  ::thrift_codegen::RObject& handler)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("MessageRouter_RemoveHandler", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_MessageRouter_RemoveHandler_pargs args;
  args.msgRouter = &msgRouter;
  args.handler = &handler;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_MessageRouter_RemoveHandler()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("MessageRouter_RemoveHandler") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_MessageRouter_RemoveHandler_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void ServerClient::MessageRouter_CancelPending(const  ::thrift_codegen::RObject& msgRouter, const int32_t bid, const  ::thrift_codegen::RObject& handler)
{
  send_MessageRouter_CancelPending(msgRouter, bid, handler);
  recv_MessageRouter_CancelPending();
}

void ServerClient::send_MessageRouter_CancelPending(const  ::thrift_codegen::RObject& msgRouter, const int32_t bid, const  ::thrift_codegen::RObject& handler)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("MessageRouter_CancelPending", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_MessageRouter_CancelPending_pargs args;
  args.msgRouter = &msgRouter;
  args.bid = &bid;
  args.handler = &handler;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_MessageRouter_CancelPending()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("MessageRouter_CancelPending") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_MessageRouter_CancelPending_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void ServerClient::QueryCallback_Dispose(const  ::thrift_codegen::RObject& qcallback)
{
  send_QueryCallback_Dispose(qcallback);
}

void ServerClient::send_QueryCallback_Dispose(const  ::thrift_codegen::RObject& qcallback)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("QueryCallback_Dispose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_QueryCallback_Dispose_pargs args;
  args.qcallback = &qcallback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::QueryCallback_Success(const  ::thrift_codegen::RObject& qcallback, const std::string& response)
{
  send_QueryCallback_Success(qcallback, response);
}

void ServerClient::send_QueryCallback_Success(const  ::thrift_codegen::RObject& qcallback, const std::string& response)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("QueryCallback_Success", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_QueryCallback_Success_pargs args;
  args.qcallback = &qcallback;
  args.response = &response;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::QueryCallback_Failure(const  ::thrift_codegen::RObject& qcallback, const int32_t error_code, const std::string& error_message)
{
  send_QueryCallback_Failure(qcallback, error_code, error_message);
}

void ServerClient::send_QueryCallback_Failure(const  ::thrift_codegen::RObject& qcallback, const int32_t error_code, const std::string& error_message)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("QueryCallback_Failure", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_QueryCallback_Failure_pargs args;
  args.qcallback = &qcallback;
  args.error_code = &error_code;
  args.error_message = &error_message;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::SchemeHandlerFactory_Register(const std::string& schemeName, const std::string& domainName, const  ::thrift_codegen::RObject& schemeHandlerFactory)
{
  send_SchemeHandlerFactory_Register(schemeName, domainName, schemeHandlerFactory);
}

void ServerClient::send_SchemeHandlerFactory_Register(const std::string& schemeName, const std::string& domainName, const  ::thrift_codegen::RObject& schemeHandlerFactory)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SchemeHandlerFactory_Register", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_SchemeHandlerFactory_Register_pargs args;
  args.schemeName = &schemeName;
  args.domainName = &domainName;
  args.schemeHandlerFactory = &schemeHandlerFactory;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::ClearAllSchemeHandlerFactories()
{
  send_ClearAllSchemeHandlerFactories();
}

void ServerClient::send_ClearAllSchemeHandlerFactories()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("ClearAllSchemeHandlerFactories", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_ClearAllSchemeHandlerFactories_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::RequestContext_ClearCertificateExceptions(const int32_t bid, const  ::thrift_codegen::RObject& completionCallback)
{
  send_RequestContext_ClearCertificateExceptions(bid, completionCallback);
}

void ServerClient::send_RequestContext_ClearCertificateExceptions(const int32_t bid, const  ::thrift_codegen::RObject& completionCallback)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("RequestContext_ClearCertificateExceptions", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_RequestContext_ClearCertificateExceptions_pargs args;
  args.bid = &bid;
  args.completionCallback = &completionCallback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::RequestContext_CloseAllConnections(const int32_t bid, const  ::thrift_codegen::RObject& completionCallback)
{
  send_RequestContext_CloseAllConnections(bid, completionCallback);
}

void ServerClient::send_RequestContext_CloseAllConnections(const int32_t bid, const  ::thrift_codegen::RObject& completionCallback)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("RequestContext_CloseAllConnections", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_RequestContext_CloseAllConnections_pargs args;
  args.bid = &bid;
  args.completionCallback = &completionCallback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::CookieManager_Create( ::thrift_codegen::RObject& _return)
{
  send_CookieManager_Create();
  recv_CookieManager_Create(_return);
}

void ServerClient::send_CookieManager_Create()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("CookieManager_Create", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_CookieManager_Create_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_CookieManager_Create( ::thrift_codegen::RObject& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("CookieManager_Create") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_CookieManager_Create_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "CookieManager_Create failed: unknown result");
}

void ServerClient::CookieManager_Dispose(const  ::thrift_codegen::RObject& cookieManager)
{
  send_CookieManager_Dispose(cookieManager);
}

void ServerClient::send_CookieManager_Dispose(const  ::thrift_codegen::RObject& cookieManager)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("CookieManager_Dispose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_CookieManager_Dispose_pargs args;
  args.cookieManager = &cookieManager;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ServerClient::CookieManager_VisitAllCookies(const  ::thrift_codegen::RObject& cookieManager, const  ::thrift_codegen::RObject& visitor)
{
  send_CookieManager_VisitAllCookies(cookieManager, visitor);
  return recv_CookieManager_VisitAllCookies();
}

void ServerClient::send_CookieManager_VisitAllCookies(const  ::thrift_codegen::RObject& cookieManager, const  ::thrift_codegen::RObject& visitor)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("CookieManager_VisitAllCookies", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_CookieManager_VisitAllCookies_pargs args;
  args.cookieManager = &cookieManager;
  args.visitor = &visitor;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ServerClient::recv_CookieManager_VisitAllCookies()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("CookieManager_VisitAllCookies") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  Server_CookieManager_VisitAllCookies_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "CookieManager_VisitAllCookies failed: unknown result");
}

bool ServerClient::CookieManager_VisitUrlCookies(const  ::thrift_codegen::RObject& cookieManager, const  ::thrift_codegen::RObject& visitor, const std::string& url, const bool includeHttpOnly)
{
  send_CookieManager_VisitUrlCookies(cookieManager, visitor, url, includeHttpOnly);
  return recv_CookieManager_VisitUrlCookies();
}

void ServerClient::send_CookieManager_VisitUrlCookies(const  ::thrift_codegen::RObject& cookieManager, const  ::thrift_codegen::RObject& visitor, const std::string& url, const bool includeHttpOnly)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("CookieManager_VisitUrlCookies", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_CookieManager_VisitUrlCookies_pargs args;
  args.cookieManager = &cookieManager;
  args.visitor = &visitor;
  args.url = &url;
  args.includeHttpOnly = &includeHttpOnly;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ServerClient::recv_CookieManager_VisitUrlCookies()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("CookieManager_VisitUrlCookies") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  Server_CookieManager_VisitUrlCookies_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "CookieManager_VisitUrlCookies failed: unknown result");
}

bool ServerClient::CookieManager_SetCookie(const  ::thrift_codegen::RObject& cookieManager, const std::string& url, const  ::thrift_codegen::Cookie& cookie)
{
  send_CookieManager_SetCookie(cookieManager, url, cookie);
  return recv_CookieManager_SetCookie();
}

void ServerClient::send_CookieManager_SetCookie(const  ::thrift_codegen::RObject& cookieManager, const std::string& url, const  ::thrift_codegen::Cookie& cookie)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("CookieManager_SetCookie", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_CookieManager_SetCookie_pargs args;
  args.cookieManager = &cookieManager;
  args.url = &url;
  args.cookie = &cookie;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ServerClient::recv_CookieManager_SetCookie()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("CookieManager_SetCookie") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  Server_CookieManager_SetCookie_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "CookieManager_SetCookie failed: unknown result");
}

bool ServerClient::CookieManager_DeleteCookies(const  ::thrift_codegen::RObject& cookieManager, const std::string& url, const std::string& cookieName)
{
  send_CookieManager_DeleteCookies(cookieManager, url, cookieName);
  return recv_CookieManager_DeleteCookies();
}

void ServerClient::send_CookieManager_DeleteCookies(const  ::thrift_codegen::RObject& cookieManager, const std::string& url, const std::string& cookieName)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("CookieManager_DeleteCookies", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_CookieManager_DeleteCookies_pargs args;
  args.cookieManager = &cookieManager;
  args.url = &url;
  args.cookieName = &cookieName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ServerClient::recv_CookieManager_DeleteCookies()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("CookieManager_DeleteCookies") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  Server_CookieManager_DeleteCookies_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "CookieManager_DeleteCookies failed: unknown result");
}

bool ServerClient::CookieManager_FlushStore(const  ::thrift_codegen::RObject& cookieManager, const  ::thrift_codegen::RObject& completionCallback)
{
  send_CookieManager_FlushStore(cookieManager, completionCallback);
  return recv_CookieManager_FlushStore();
}

void ServerClient::send_CookieManager_FlushStore(const  ::thrift_codegen::RObject& cookieManager, const  ::thrift_codegen::RObject& completionCallback)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("CookieManager_FlushStore", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_CookieManager_FlushStore_pargs args;
  args.cookieManager = &cookieManager;
  args.completionCallback = &completionCallback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ServerClient::recv_CookieManager_FlushStore()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("CookieManager_FlushStore") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  Server_CookieManager_FlushStore_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "CookieManager_FlushStore failed: unknown result");
}

bool ServerProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void ServerProcessor::process_connect(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.connect", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.connect");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.connect");
  }

  Server_connect_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.connect", bytes);
  }

  Server_connect_result result;
  try {
    result.success = iface_->connect(args.backwardConnectionPipe, args.isMaster);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.connect");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("connect", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.connect");
  }

  oprot->writeMessageBegin("connect", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.connect", bytes);
  }
}

void ServerProcessor::process_connectTcp(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.connectTcp", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.connectTcp");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.connectTcp");
  }

  Server_connectTcp_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.connectTcp", bytes);
  }

  Server_connectTcp_result result;
  try {
    result.success = iface_->connectTcp(args.backwardConnectionPort, args.isMaster);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.connectTcp");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("connectTcp", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.connectTcp");
  }

  oprot->writeMessageBegin("connectTcp", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.connectTcp", bytes);
  }
}

void ServerProcessor::process_log(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.log", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.log");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.log");
  }

  Server_log_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.log", bytes);
  }

  try {
    iface_->log(args.msg);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.log");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.log");
  }

  return;
}

void ServerProcessor::process_echo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.echo", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.echo");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.echo");
  }

  Server_echo_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.echo", bytes);
  }

  Server_echo_result result;
  try {
    iface_->echo(result.success, args.msg);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.echo");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("echo", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.echo");
  }

  oprot->writeMessageBegin("echo", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.echo", bytes);
  }
}

void ServerProcessor::process_version(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.version", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.version");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.version");
  }

  Server_version_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.version", bytes);
  }

  Server_version_result result;
  try {
    iface_->version(result.success);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.version");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("version", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.version");
  }

  oprot->writeMessageBegin("version", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.version", bytes);
  }
}

void ServerProcessor::process_state(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.state", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.state");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.state");
  }

  Server_state_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.state", bytes);
  }

  Server_state_result result;
  try {
    iface_->state(result.success);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.state");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("state", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.state");
  }

  oprot->writeMessageBegin("state", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.state", bytes);
  }
}

void ServerProcessor::process_stop(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.stop", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.stop");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.stop");
  }

  Server_stop_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.stop", bytes);
  }

  try {
    iface_->stop();
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.stop");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.stop");
  }

  return;
}

void ServerProcessor::process_Browser_Create(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_Create", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_Create");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_Create");
  }

  Server_Browser_Create_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_Create", bytes);
  }

  Server_Browser_Create_result result;
  try {
    result.success = iface_->Browser_Create(args.cid, args.handlersMask, args.requestContextHandler);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_Create");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Browser_Create", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Browser_Create");
  }

  oprot->writeMessageBegin("Browser_Create", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Browser_Create", bytes);
  }
}

void ServerProcessor::process_Browser_StartNativeCreation(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_StartNativeCreation", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_StartNativeCreation");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_StartNativeCreation");
  }

  Server_Browser_StartNativeCreation_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_StartNativeCreation", bytes);
  }

  try {
    iface_->Browser_StartNativeCreation(args.bid, args.url);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_StartNativeCreation");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_StartNativeCreation");
  }

  return;
}

void ServerProcessor::process_Browser_Close(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_Close", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_Close");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_Close");
  }

  Server_Browser_Close_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_Close", bytes);
  }

  try {
    iface_->Browser_Close(args.bid);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_Close");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_Close");
  }

  return;
}

void ServerProcessor::process_Browser_Reload(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_Reload", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_Reload");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_Reload");
  }

  Server_Browser_Reload_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_Reload", bytes);
  }

  try {
    iface_->Browser_Reload(args.bid);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_Reload");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_Reload");
  }

  return;
}

void ServerProcessor::process_Browser_ReloadIgnoreCache(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_ReloadIgnoreCache", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_ReloadIgnoreCache");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_ReloadIgnoreCache");
  }

  Server_Browser_ReloadIgnoreCache_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_ReloadIgnoreCache", bytes);
  }

  try {
    iface_->Browser_ReloadIgnoreCache(args.bid);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_ReloadIgnoreCache");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_ReloadIgnoreCache");
  }

  return;
}

void ServerProcessor::process_Browser_LoadURL(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_LoadURL", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_LoadURL");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_LoadURL");
  }

  Server_Browser_LoadURL_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_LoadURL", bytes);
  }

  try {
    iface_->Browser_LoadURL(args.bid, args.url);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_LoadURL");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_LoadURL");
  }

  return;
}

void ServerProcessor::process_Browser_LoadRequest(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_LoadRequest", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_LoadRequest");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_LoadRequest");
  }

  Server_Browser_LoadRequest_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_LoadRequest", bytes);
  }

  try {
    iface_->Browser_LoadRequest(args.bid, args.request);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_LoadRequest");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_LoadRequest");
  }

  return;
}

void ServerProcessor::process_Browser_GetURL(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_GetURL", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_GetURL");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_GetURL");
  }

  Server_Browser_GetURL_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_GetURL", bytes);
  }

  Server_Browser_GetURL_result result;
  try {
    iface_->Browser_GetURL(result.success, args.bid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_GetURL");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Browser_GetURL", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Browser_GetURL");
  }

  oprot->writeMessageBegin("Browser_GetURL", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Browser_GetURL", bytes);
  }
}

void ServerProcessor::process_Browser_ExecuteJavaScript(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_ExecuteJavaScript", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_ExecuteJavaScript");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_ExecuteJavaScript");
  }

  Server_Browser_ExecuteJavaScript_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_ExecuteJavaScript", bytes);
  }

  try {
    iface_->Browser_ExecuteJavaScript(args.bid, args.code, args.url, args.line);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_ExecuteJavaScript");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_ExecuteJavaScript");
  }

  return;
}

void ServerProcessor::process_Browser_WasResized(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_WasResized", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_WasResized");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_WasResized");
  }

  Server_Browser_WasResized_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_WasResized", bytes);
  }

  try {
    iface_->Browser_WasResized(args.bid);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_WasResized");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_WasResized");
  }

  return;
}

void ServerProcessor::process_Browser_NotifyScreenInfoChanged(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_NotifyScreenInfoChanged", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_NotifyScreenInfoChanged");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_NotifyScreenInfoChanged");
  }

  Server_Browser_NotifyScreenInfoChanged_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_NotifyScreenInfoChanged", bytes);
  }

  try {
    iface_->Browser_NotifyScreenInfoChanged(args.bid);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_NotifyScreenInfoChanged");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_NotifyScreenInfoChanged");
  }

  return;
}

void ServerProcessor::process_Browser_SendKeyEvent(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_SendKeyEvent", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_SendKeyEvent");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_SendKeyEvent");
  }

  Server_Browser_SendKeyEvent_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_SendKeyEvent", bytes);
  }

  try {
    iface_->Browser_SendKeyEvent(args.bid, args.event_type, args.modifiers, args.key_char, args.scanCode, args.key_code);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_SendKeyEvent");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_SendKeyEvent");
  }

  return;
}

void ServerProcessor::process_Browser_SendMouseEvent(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_SendMouseEvent", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_SendMouseEvent");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_SendMouseEvent");
  }

  Server_Browser_SendMouseEvent_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_SendMouseEvent", bytes);
  }

  try {
    iface_->Browser_SendMouseEvent(args.bid, args.event_type, args.x, args.y, args.modifiers, args.click_count, args.button);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_SendMouseEvent");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_SendMouseEvent");
  }

  return;
}

void ServerProcessor::process_Browser_SendMouseWheelEvent(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_SendMouseWheelEvent", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_SendMouseWheelEvent");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_SendMouseWheelEvent");
  }

  Server_Browser_SendMouseWheelEvent_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_SendMouseWheelEvent", bytes);
  }

  try {
    iface_->Browser_SendMouseWheelEvent(args.bid, args.scroll_type, args.x, args.y, args.modifiers, args.delta, args.units_to_scroll);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_SendMouseWheelEvent");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_SendMouseWheelEvent");
  }

  return;
}

void ServerProcessor::process_Browser_CanGoForward(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_CanGoForward", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_CanGoForward");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_CanGoForward");
  }

  Server_Browser_CanGoForward_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_CanGoForward", bytes);
  }

  Server_Browser_CanGoForward_result result;
  try {
    result.success = iface_->Browser_CanGoForward(args.bid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_CanGoForward");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Browser_CanGoForward", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Browser_CanGoForward");
  }

  oprot->writeMessageBegin("Browser_CanGoForward", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Browser_CanGoForward", bytes);
  }
}

void ServerProcessor::process_Browser_CanGoBack(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_CanGoBack", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_CanGoBack");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_CanGoBack");
  }

  Server_Browser_CanGoBack_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_CanGoBack", bytes);
  }

  Server_Browser_CanGoBack_result result;
  try {
    result.success = iface_->Browser_CanGoBack(args.bid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_CanGoBack");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Browser_CanGoBack", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Browser_CanGoBack");
  }

  oprot->writeMessageBegin("Browser_CanGoBack", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Browser_CanGoBack", bytes);
  }
}

void ServerProcessor::process_Browser_GoBack(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_GoBack", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_GoBack");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_GoBack");
  }

  Server_Browser_GoBack_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_GoBack", bytes);
  }

  try {
    iface_->Browser_GoBack(args.bid);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_GoBack");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_GoBack");
  }

  return;
}

void ServerProcessor::process_Browser_GoForward(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_GoForward", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_GoForward");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_GoForward");
  }

  Server_Browser_GoForward_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_GoForward", bytes);
  }

  try {
    iface_->Browser_GoForward(args.bid);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_GoForward");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_GoForward");
  }

  return;
}

void ServerProcessor::process_Browser_IsLoading(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_IsLoading", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_IsLoading");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_IsLoading");
  }

  Server_Browser_IsLoading_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_IsLoading", bytes);
  }

  Server_Browser_IsLoading_result result;
  try {
    result.success = iface_->Browser_IsLoading(args.bid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_IsLoading");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Browser_IsLoading", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Browser_IsLoading");
  }

  oprot->writeMessageBegin("Browser_IsLoading", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Browser_IsLoading", bytes);
  }
}

void ServerProcessor::process_Browser_StopLoad(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_StopLoad", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_StopLoad");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_StopLoad");
  }

  Server_Browser_StopLoad_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_StopLoad", bytes);
  }

  try {
    iface_->Browser_StopLoad(args.bid);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_StopLoad");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_StopLoad");
  }

  return;
}

void ServerProcessor::process_Browser_GetMainFrame(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_GetMainFrame", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_GetMainFrame");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_GetMainFrame");
  }

  Server_Browser_GetMainFrame_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_GetMainFrame", bytes);
  }

  Server_Browser_GetMainFrame_result result;
  try {
    iface_->Browser_GetMainFrame(result.success, args.bid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_GetMainFrame");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Browser_GetMainFrame", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Browser_GetMainFrame");
  }

  oprot->writeMessageBegin("Browser_GetMainFrame", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Browser_GetMainFrame", bytes);
  }
}

void ServerProcessor::process_Browser_GetFocusedFrame(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_GetFocusedFrame", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_GetFocusedFrame");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_GetFocusedFrame");
  }

  Server_Browser_GetFocusedFrame_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_GetFocusedFrame", bytes);
  }

  Server_Browser_GetFocusedFrame_result result;
  try {
    iface_->Browser_GetFocusedFrame(result.success, args.bid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_GetFocusedFrame");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Browser_GetFocusedFrame", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Browser_GetFocusedFrame");
  }

  oprot->writeMessageBegin("Browser_GetFocusedFrame", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Browser_GetFocusedFrame", bytes);
  }
}

void ServerProcessor::process_Browser_GetFrameByIdentifier(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_GetFrameByIdentifier", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_GetFrameByIdentifier");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_GetFrameByIdentifier");
  }

  Server_Browser_GetFrameByIdentifier_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_GetFrameByIdentifier", bytes);
  }

  Server_Browser_GetFrameByIdentifier_result result;
  try {
    iface_->Browser_GetFrameByIdentifier(result.success, args.bid, args.identifier);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_GetFrameByIdentifier");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Browser_GetFrameByIdentifier", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Browser_GetFrameByIdentifier");
  }

  oprot->writeMessageBegin("Browser_GetFrameByIdentifier", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Browser_GetFrameByIdentifier", bytes);
  }
}

void ServerProcessor::process_Browser_GetFrameByName(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_GetFrameByName", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_GetFrameByName");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_GetFrameByName");
  }

  Server_Browser_GetFrameByName_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_GetFrameByName", bytes);
  }

  Server_Browser_GetFrameByName_result result;
  try {
    iface_->Browser_GetFrameByName(result.success, args.bid, args.name);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_GetFrameByName");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Browser_GetFrameByName", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Browser_GetFrameByName");
  }

  oprot->writeMessageBegin("Browser_GetFrameByName", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Browser_GetFrameByName", bytes);
  }
}

void ServerProcessor::process_Browser_GetFrameCount(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_GetFrameCount", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_GetFrameCount");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_GetFrameCount");
  }

  Server_Browser_GetFrameCount_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_GetFrameCount", bytes);
  }

  Server_Browser_GetFrameCount_result result;
  try {
    result.success = iface_->Browser_GetFrameCount(args.bid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_GetFrameCount");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Browser_GetFrameCount", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Browser_GetFrameCount");
  }

  oprot->writeMessageBegin("Browser_GetFrameCount", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Browser_GetFrameCount", bytes);
  }
}

void ServerProcessor::process_Browser_GetFrameIdentifiers(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_GetFrameIdentifiers", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_GetFrameIdentifiers");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_GetFrameIdentifiers");
  }

  Server_Browser_GetFrameIdentifiers_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_GetFrameIdentifiers", bytes);
  }

  Server_Browser_GetFrameIdentifiers_result result;
  try {
    iface_->Browser_GetFrameIdentifiers(result.success, args.bid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_GetFrameIdentifiers");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Browser_GetFrameIdentifiers", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Browser_GetFrameIdentifiers");
  }

  oprot->writeMessageBegin("Browser_GetFrameIdentifiers", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Browser_GetFrameIdentifiers", bytes);
  }
}

void ServerProcessor::process_Browser_GetFrameNames(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_GetFrameNames", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_GetFrameNames");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_GetFrameNames");
  }

  Server_Browser_GetFrameNames_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_GetFrameNames", bytes);
  }

  Server_Browser_GetFrameNames_result result;
  try {
    iface_->Browser_GetFrameNames(result.success, args.bid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_GetFrameNames");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Browser_GetFrameNames", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Browser_GetFrameNames");
  }

  oprot->writeMessageBegin("Browser_GetFrameNames", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Browser_GetFrameNames", bytes);
  }
}

void ServerProcessor::process_Browser_IsPopup(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_IsPopup", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_IsPopup");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_IsPopup");
  }

  Server_Browser_IsPopup_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_IsPopup", bytes);
  }

  Server_Browser_IsPopup_result result;
  try {
    result.success = iface_->Browser_IsPopup(args.bid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_IsPopup");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Browser_IsPopup", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Browser_IsPopup");
  }

  oprot->writeMessageBegin("Browser_IsPopup", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Browser_IsPopup", bytes);
  }
}

void ServerProcessor::process_Browser_HasDocument(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_HasDocument", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_HasDocument");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_HasDocument");
  }

  Server_Browser_HasDocument_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_HasDocument", bytes);
  }

  Server_Browser_HasDocument_result result;
  try {
    result.success = iface_->Browser_HasDocument(args.bid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_HasDocument");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Browser_HasDocument", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Browser_HasDocument");
  }

  oprot->writeMessageBegin("Browser_HasDocument", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Browser_HasDocument", bytes);
  }
}

void ServerProcessor::process_Browser_ViewSource(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_ViewSource", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_ViewSource");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_ViewSource");
  }

  Server_Browser_ViewSource_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_ViewSource", bytes);
  }

  try {
    iface_->Browser_ViewSource(args.bid);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_ViewSource");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_ViewSource");
  }

  return;
}

void ServerProcessor::process_Browser_GetSource(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_GetSource", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_GetSource");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_GetSource");
  }

  Server_Browser_GetSource_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_GetSource", bytes);
  }

  try {
    iface_->Browser_GetSource(args.bid, args.stringVisitor);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_GetSource");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_GetSource");
  }

  return;
}

void ServerProcessor::process_Browser_GetText(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_GetText", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_GetText");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_GetText");
  }

  Server_Browser_GetText_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_GetText", bytes);
  }

  try {
    iface_->Browser_GetText(args.bid, args.stringVisitor);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_GetText");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_GetText");
  }

  return;
}

void ServerProcessor::process_Browser_SetFocus(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_SetFocus", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_SetFocus");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_SetFocus");
  }

  Server_Browser_SetFocus_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_SetFocus", bytes);
  }

  try {
    iface_->Browser_SetFocus(args.bid, args.enable);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_SetFocus");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_SetFocus");
  }

  return;
}

void ServerProcessor::process_Browser_GetZoomLevel(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_GetZoomLevel", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_GetZoomLevel");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_GetZoomLevel");
  }

  Server_Browser_GetZoomLevel_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_GetZoomLevel", bytes);
  }

  Server_Browser_GetZoomLevel_result result;
  try {
    result.success = iface_->Browser_GetZoomLevel(args.bid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_GetZoomLevel");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Browser_GetZoomLevel", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Browser_GetZoomLevel");
  }

  oprot->writeMessageBegin("Browser_GetZoomLevel", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Browser_GetZoomLevel", bytes);
  }
}

void ServerProcessor::process_Browser_SetZoomLevel(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_SetZoomLevel", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_SetZoomLevel");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_SetZoomLevel");
  }

  Server_Browser_SetZoomLevel_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_SetZoomLevel", bytes);
  }

  try {
    iface_->Browser_SetZoomLevel(args.bid, args.val);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_SetZoomLevel");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_SetZoomLevel");
  }

  return;
}

void ServerProcessor::process_Browser_StartDownload(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_StartDownload", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_StartDownload");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_StartDownload");
  }

  Server_Browser_StartDownload_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_StartDownload", bytes);
  }

  try {
    iface_->Browser_StartDownload(args.bid, args.url);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_StartDownload");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_StartDownload");
  }

  return;
}

void ServerProcessor::process_Browser_Find(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_Find", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_Find");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_Find");
  }

  Server_Browser_Find_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_Find", bytes);
  }

  try {
    iface_->Browser_Find(args.bid, args.searchText, args.forward, args.matchCase, args.findNext);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_Find");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_Find");
  }

  return;
}

void ServerProcessor::process_Browser_StopFinding(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_StopFinding", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_StopFinding");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_StopFinding");
  }

  Server_Browser_StopFinding_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_StopFinding", bytes);
  }

  try {
    iface_->Browser_StopFinding(args.bid, args.clearSelection);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_StopFinding");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_StopFinding");
  }

  return;
}

void ServerProcessor::process_Browser_ReplaceMisspelling(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_ReplaceMisspelling", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_ReplaceMisspelling");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_ReplaceMisspelling");
  }

  Server_Browser_ReplaceMisspelling_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_ReplaceMisspelling", bytes);
  }

  try {
    iface_->Browser_ReplaceMisspelling(args.bid, args.word);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_ReplaceMisspelling");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_ReplaceMisspelling");
  }

  return;
}

void ServerProcessor::process_Browser_SetFrameRate(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_SetFrameRate", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_SetFrameRate");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_SetFrameRate");
  }

  Server_Browser_SetFrameRate_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_SetFrameRate", bytes);
  }

  try {
    iface_->Browser_SetFrameRate(args.bid, args.val);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_SetFrameRate");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_SetFrameRate");
  }

  return;
}

void ServerProcessor::process_Frame_ExecuteJavaScript(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Frame_ExecuteJavaScript", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Frame_ExecuteJavaScript");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Frame_ExecuteJavaScript");
  }

  Server_Frame_ExecuteJavaScript_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Frame_ExecuteJavaScript", bytes);
  }

  try {
    iface_->Frame_ExecuteJavaScript(args.frameId, args.code, args.url, args.line);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Frame_ExecuteJavaScript");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Frame_ExecuteJavaScript");
  }

  return;
}

void ServerProcessor::process_Frame_Dispose(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Frame_Dispose", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Frame_Dispose");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Frame_Dispose");
  }

  Server_Frame_Dispose_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Frame_Dispose", bytes);
  }

  try {
    iface_->Frame_Dispose(args.frameId);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Frame_Dispose");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Frame_Dispose");
  }

  return;
}

void ServerProcessor::process_Frame_GetParent(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Frame_GetParent", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Frame_GetParent");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Frame_GetParent");
  }

  Server_Frame_GetParent_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Frame_GetParent", bytes);
  }

  Server_Frame_GetParent_result result;
  try {
    iface_->Frame_GetParent(result.success, args.frameId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Frame_GetParent");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Frame_GetParent", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Frame_GetParent");
  }

  oprot->writeMessageBegin("Frame_GetParent", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Frame_GetParent", bytes);
  }
}

void ServerProcessor::process_Frame_Undo(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Frame_Undo", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Frame_Undo");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Frame_Undo");
  }

  Server_Frame_Undo_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Frame_Undo", bytes);
  }

  try {
    iface_->Frame_Undo(args.frameId);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Frame_Undo");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Frame_Undo");
  }

  return;
}

void ServerProcessor::process_Frame_Redo(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Frame_Redo", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Frame_Redo");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Frame_Redo");
  }

  Server_Frame_Redo_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Frame_Redo", bytes);
  }

  try {
    iface_->Frame_Redo(args.frameId);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Frame_Redo");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Frame_Redo");
  }

  return;
}

void ServerProcessor::process_Frame_Cut(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Frame_Cut", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Frame_Cut");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Frame_Cut");
  }

  Server_Frame_Cut_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Frame_Cut", bytes);
  }

  try {
    iface_->Frame_Cut(args.frameId);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Frame_Cut");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Frame_Cut");
  }

  return;
}

void ServerProcessor::process_Frame_Copy(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Frame_Copy", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Frame_Copy");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Frame_Copy");
  }

  Server_Frame_Copy_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Frame_Copy", bytes);
  }

  try {
    iface_->Frame_Copy(args.frameId);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Frame_Copy");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Frame_Copy");
  }

  return;
}

void ServerProcessor::process_Frame_Paste(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Frame_Paste", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Frame_Paste");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Frame_Paste");
  }

  Server_Frame_Paste_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Frame_Paste", bytes);
  }

  try {
    iface_->Frame_Paste(args.frameId);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Frame_Paste");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Frame_Paste");
  }

  return;
}

void ServerProcessor::process_Frame_Delete(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Frame_Delete", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Frame_Delete");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Frame_Delete");
  }

  Server_Frame_Delete_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Frame_Delete", bytes);
  }

  try {
    iface_->Frame_Delete(args.frameId);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Frame_Delete");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Frame_Delete");
  }

  return;
}

void ServerProcessor::process_Frame_SelectAll(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Frame_SelectAll", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Frame_SelectAll");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Frame_SelectAll");
  }

  Server_Frame_SelectAll_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Frame_SelectAll", bytes);
  }

  try {
    iface_->Frame_SelectAll(args.frameId);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Frame_SelectAll");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Frame_SelectAll");
  }

  return;
}

void ServerProcessor::process_Request_Create(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Request_Create", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Request_Create");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Request_Create");
  }

  Server_Request_Create_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Request_Create", bytes);
  }

  Server_Request_Create_result result;
  try {
    iface_->Request_Create(result.success);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Request_Create");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Request_Create", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Request_Create");
  }

  oprot->writeMessageBegin("Request_Create", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Request_Create", bytes);
  }
}

void ServerProcessor::process_Request_Dispose(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Request_Dispose", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Request_Dispose");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Request_Dispose");
  }

  Server_Request_Dispose_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Request_Dispose", bytes);
  }

  try {
    iface_->Request_Dispose(args.requestId);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Request_Dispose");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Request_Dispose");
  }

  return;
}

void ServerProcessor::process_Request_Update(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Request_Update", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Request_Update");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Request_Update");
  }

  Server_Request_Update_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Request_Update", bytes);
  }

  Server_Request_Update_result result;
  try {
    iface_->Request_Update(args.request);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Request_Update");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Request_Update", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Request_Update");
  }

  oprot->writeMessageBegin("Request_Update", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Request_Update", bytes);
  }
}

void ServerProcessor::process_Request_GetPostData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Request_GetPostData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Request_GetPostData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Request_GetPostData");
  }

  Server_Request_GetPostData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Request_GetPostData", bytes);
  }

  Server_Request_GetPostData_result result;
  try {
    iface_->Request_GetPostData(result.success, args.request);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Request_GetPostData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Request_GetPostData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Request_GetPostData");
  }

  oprot->writeMessageBegin("Request_GetPostData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Request_GetPostData", bytes);
  }
}

void ServerProcessor::process_Request_SetPostData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Request_SetPostData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Request_SetPostData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Request_SetPostData");
  }

  Server_Request_SetPostData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Request_SetPostData", bytes);
  }

  Server_Request_SetPostData_result result;
  try {
    iface_->Request_SetPostData(args.request, args.postData);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Request_SetPostData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Request_SetPostData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Request_SetPostData");
  }

  oprot->writeMessageBegin("Request_SetPostData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Request_SetPostData", bytes);
  }
}

void ServerProcessor::process_Request_GetHeaderByName(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Request_GetHeaderByName", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Request_GetHeaderByName");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Request_GetHeaderByName");
  }

  Server_Request_GetHeaderByName_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Request_GetHeaderByName", bytes);
  }

  Server_Request_GetHeaderByName_result result;
  try {
    iface_->Request_GetHeaderByName(result.success, args.request, args.name);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Request_GetHeaderByName");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Request_GetHeaderByName", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Request_GetHeaderByName");
  }

  oprot->writeMessageBegin("Request_GetHeaderByName", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Request_GetHeaderByName", bytes);
  }
}

void ServerProcessor::process_Request_SetHeaderByName(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Request_SetHeaderByName", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Request_SetHeaderByName");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Request_SetHeaderByName");
  }

  Server_Request_SetHeaderByName_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Request_SetHeaderByName", bytes);
  }

  Server_Request_SetHeaderByName_result result;
  try {
    iface_->Request_SetHeaderByName(args.request, args.name, args.value, args.overwrite);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Request_SetHeaderByName");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Request_SetHeaderByName", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Request_SetHeaderByName");
  }

  oprot->writeMessageBegin("Request_SetHeaderByName", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Request_SetHeaderByName", bytes);
  }
}

void ServerProcessor::process_Request_GetHeaderMap(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Request_GetHeaderMap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Request_GetHeaderMap");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Request_GetHeaderMap");
  }

  Server_Request_GetHeaderMap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Request_GetHeaderMap", bytes);
  }

  Server_Request_GetHeaderMap_result result;
  try {
    iface_->Request_GetHeaderMap(result.success, args.request);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Request_GetHeaderMap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Request_GetHeaderMap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Request_GetHeaderMap");
  }

  oprot->writeMessageBegin("Request_GetHeaderMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Request_GetHeaderMap", bytes);
  }
}

void ServerProcessor::process_Request_SetHeaderMap(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Request_SetHeaderMap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Request_SetHeaderMap");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Request_SetHeaderMap");
  }

  Server_Request_SetHeaderMap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Request_SetHeaderMap", bytes);
  }

  Server_Request_SetHeaderMap_result result;
  try {
    iface_->Request_SetHeaderMap(args.request, args.headerMap);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Request_SetHeaderMap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Request_SetHeaderMap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Request_SetHeaderMap");
  }

  oprot->writeMessageBegin("Request_SetHeaderMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Request_SetHeaderMap", bytes);
  }
}

void ServerProcessor::process_Request_Set(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Request_Set", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Request_Set");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Request_Set");
  }

  Server_Request_Set_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Request_Set", bytes);
  }

  Server_Request_Set_result result;
  try {
    iface_->Request_Set(args.request, args.url, args.method, args.postData, args.headerMap);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Request_Set");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Request_Set", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Request_Set");
  }

  oprot->writeMessageBegin("Request_Set", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Request_Set", bytes);
  }
}

void ServerProcessor::process_Response_Update(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Response_Update", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Response_Update");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Response_Update");
  }

  Server_Response_Update_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Response_Update", bytes);
  }

  Server_Response_Update_result result;
  try {
    iface_->Response_Update(args.response);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Response_Update");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Response_Update", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Response_Update");
  }

  oprot->writeMessageBegin("Response_Update", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Response_Update", bytes);
  }
}

void ServerProcessor::process_Response_GetHeaderByName(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Response_GetHeaderByName", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Response_GetHeaderByName");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Response_GetHeaderByName");
  }

  Server_Response_GetHeaderByName_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Response_GetHeaderByName", bytes);
  }

  Server_Response_GetHeaderByName_result result;
  try {
    iface_->Response_GetHeaderByName(result.success, args.response, args.name);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Response_GetHeaderByName");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Response_GetHeaderByName", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Response_GetHeaderByName");
  }

  oprot->writeMessageBegin("Response_GetHeaderByName", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Response_GetHeaderByName", bytes);
  }
}

void ServerProcessor::process_Response_SetHeaderByName(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Response_SetHeaderByName", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Response_SetHeaderByName");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Response_SetHeaderByName");
  }

  Server_Response_SetHeaderByName_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Response_SetHeaderByName", bytes);
  }

  Server_Response_SetHeaderByName_result result;
  try {
    iface_->Response_SetHeaderByName(args.response, args.name, args.value, args.overwrite);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Response_SetHeaderByName");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Response_SetHeaderByName", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Response_SetHeaderByName");
  }

  oprot->writeMessageBegin("Response_SetHeaderByName", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Response_SetHeaderByName", bytes);
  }
}

void ServerProcessor::process_Response_GetHeaderMap(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Response_GetHeaderMap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Response_GetHeaderMap");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Response_GetHeaderMap");
  }

  Server_Response_GetHeaderMap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Response_GetHeaderMap", bytes);
  }

  Server_Response_GetHeaderMap_result result;
  try {
    iface_->Response_GetHeaderMap(result.success, args.response);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Response_GetHeaderMap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Response_GetHeaderMap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Response_GetHeaderMap");
  }

  oprot->writeMessageBegin("Response_GetHeaderMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Response_GetHeaderMap", bytes);
  }
}

void ServerProcessor::process_Response_SetHeaderMap(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Response_SetHeaderMap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Response_SetHeaderMap");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Response_SetHeaderMap");
  }

  Server_Response_SetHeaderMap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Response_SetHeaderMap", bytes);
  }

  Server_Response_SetHeaderMap_result result;
  try {
    iface_->Response_SetHeaderMap(args.response, args.headerMap);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Response_SetHeaderMap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Response_SetHeaderMap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Response_SetHeaderMap");
  }

  oprot->writeMessageBegin("Response_SetHeaderMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Response_SetHeaderMap", bytes);
  }
}

void ServerProcessor::process_Callback_Dispose(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Callback_Dispose", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Callback_Dispose");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Callback_Dispose");
  }

  Server_Callback_Dispose_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Callback_Dispose", bytes);
  }

  try {
    iface_->Callback_Dispose(args.callback);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Callback_Dispose");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Callback_Dispose");
  }

  return;
}

void ServerProcessor::process_Callback_Continue(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Callback_Continue", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Callback_Continue");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Callback_Continue");
  }

  Server_Callback_Continue_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Callback_Continue", bytes);
  }

  try {
    iface_->Callback_Continue(args.callback);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Callback_Continue");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Callback_Continue");
  }

  return;
}

void ServerProcessor::process_Callback_Cancel(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Callback_Cancel", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Callback_Cancel");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Callback_Cancel");
  }

  Server_Callback_Cancel_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Callback_Cancel", bytes);
  }

  try {
    iface_->Callback_Cancel(args.callback);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Callback_Cancel");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Callback_Cancel");
  }

  return;
}

void ServerProcessor::process_AuthCallback_Dispose(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.AuthCallback_Dispose", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.AuthCallback_Dispose");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.AuthCallback_Dispose");
  }

  Server_AuthCallback_Dispose_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.AuthCallback_Dispose", bytes);
  }

  try {
    iface_->AuthCallback_Dispose(args.authCallback);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.AuthCallback_Dispose");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.AuthCallback_Dispose");
  }

  return;
}

void ServerProcessor::process_AuthCallback_Continue(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.AuthCallback_Continue", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.AuthCallback_Continue");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.AuthCallback_Continue");
  }

  Server_AuthCallback_Continue_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.AuthCallback_Continue", bytes);
  }

  try {
    iface_->AuthCallback_Continue(args.authCallback, args.username, args.password);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.AuthCallback_Continue");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.AuthCallback_Continue");
  }

  return;
}

void ServerProcessor::process_AuthCallback_Cancel(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.AuthCallback_Cancel", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.AuthCallback_Cancel");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.AuthCallback_Cancel");
  }

  Server_AuthCallback_Cancel_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.AuthCallback_Cancel", bytes);
  }

  try {
    iface_->AuthCallback_Cancel(args.authCallback);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.AuthCallback_Cancel");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.AuthCallback_Cancel");
  }

  return;
}

void ServerProcessor::process_MessageRouter_Create(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.MessageRouter_Create", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.MessageRouter_Create");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.MessageRouter_Create");
  }

  Server_MessageRouter_Create_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.MessageRouter_Create", bytes);
  }

  Server_MessageRouter_Create_result result;
  try {
    iface_->MessageRouter_Create(result.success, args.query, args.cancel);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.MessageRouter_Create");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("MessageRouter_Create", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.MessageRouter_Create");
  }

  oprot->writeMessageBegin("MessageRouter_Create", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.MessageRouter_Create", bytes);
  }
}

void ServerProcessor::process_MessageRouter_Dispose(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.MessageRouter_Dispose", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.MessageRouter_Dispose");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.MessageRouter_Dispose");
  }

  Server_MessageRouter_Dispose_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.MessageRouter_Dispose", bytes);
  }

  try {
    iface_->MessageRouter_Dispose(args.msgRouter);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.MessageRouter_Dispose");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.MessageRouter_Dispose");
  }

  return;
}

void ServerProcessor::process_MessageRouter_AddMessageRouterToBrowser(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.MessageRouter_AddMessageRouterToBrowser", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.MessageRouter_AddMessageRouterToBrowser");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.MessageRouter_AddMessageRouterToBrowser");
  }

  Server_MessageRouter_AddMessageRouterToBrowser_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.MessageRouter_AddMessageRouterToBrowser", bytes);
  }

  Server_MessageRouter_AddMessageRouterToBrowser_result result;
  try {
    iface_->MessageRouter_AddMessageRouterToBrowser(args.msgRouter, args.bid);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.MessageRouter_AddMessageRouterToBrowser");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("MessageRouter_AddMessageRouterToBrowser", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.MessageRouter_AddMessageRouterToBrowser");
  }

  oprot->writeMessageBegin("MessageRouter_AddMessageRouterToBrowser", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.MessageRouter_AddMessageRouterToBrowser", bytes);
  }
}

void ServerProcessor::process_MessageRouter_RemoveMessageRouterFromBrowser(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.MessageRouter_RemoveMessageRouterFromBrowser", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.MessageRouter_RemoveMessageRouterFromBrowser");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.MessageRouter_RemoveMessageRouterFromBrowser");
  }

  Server_MessageRouter_RemoveMessageRouterFromBrowser_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.MessageRouter_RemoveMessageRouterFromBrowser", bytes);
  }

  Server_MessageRouter_RemoveMessageRouterFromBrowser_result result;
  try {
    iface_->MessageRouter_RemoveMessageRouterFromBrowser(args.msgRouter, args.bid);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.MessageRouter_RemoveMessageRouterFromBrowser");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("MessageRouter_RemoveMessageRouterFromBrowser", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.MessageRouter_RemoveMessageRouterFromBrowser");
  }

  oprot->writeMessageBegin("MessageRouter_RemoveMessageRouterFromBrowser", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.MessageRouter_RemoveMessageRouterFromBrowser", bytes);
  }
}

void ServerProcessor::process_MessageRouter_AddHandler(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.MessageRouter_AddHandler", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.MessageRouter_AddHandler");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.MessageRouter_AddHandler");
  }

  Server_MessageRouter_AddHandler_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.MessageRouter_AddHandler", bytes);
  }

  Server_MessageRouter_AddHandler_result result;
  try {
    iface_->MessageRouter_AddHandler(args.msgRouter, args.handler, args.first);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.MessageRouter_AddHandler");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("MessageRouter_AddHandler", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.MessageRouter_AddHandler");
  }

  oprot->writeMessageBegin("MessageRouter_AddHandler", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.MessageRouter_AddHandler", bytes);
  }
}

void ServerProcessor::process_MessageRouter_RemoveHandler(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.MessageRouter_RemoveHandler", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.MessageRouter_RemoveHandler");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.MessageRouter_RemoveHandler");
  }

  Server_MessageRouter_RemoveHandler_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.MessageRouter_RemoveHandler", bytes);
  }

  Server_MessageRouter_RemoveHandler_result result;
  try {
    iface_->MessageRouter_RemoveHandler(args.msgRouter, args.handler);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.MessageRouter_RemoveHandler");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("MessageRouter_RemoveHandler", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.MessageRouter_RemoveHandler");
  }

  oprot->writeMessageBegin("MessageRouter_RemoveHandler", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.MessageRouter_RemoveHandler", bytes);
  }
}

void ServerProcessor::process_MessageRouter_CancelPending(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.MessageRouter_CancelPending", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.MessageRouter_CancelPending");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.MessageRouter_CancelPending");
  }

  Server_MessageRouter_CancelPending_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.MessageRouter_CancelPending", bytes);
  }

  Server_MessageRouter_CancelPending_result result;
  try {
    iface_->MessageRouter_CancelPending(args.msgRouter, args.bid, args.handler);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.MessageRouter_CancelPending");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("MessageRouter_CancelPending", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.MessageRouter_CancelPending");
  }

  oprot->writeMessageBegin("MessageRouter_CancelPending", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.MessageRouter_CancelPending", bytes);
  }
}

void ServerProcessor::process_QueryCallback_Dispose(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.QueryCallback_Dispose", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.QueryCallback_Dispose");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.QueryCallback_Dispose");
  }

  Server_QueryCallback_Dispose_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.QueryCallback_Dispose", bytes);
  }

  try {
    iface_->QueryCallback_Dispose(args.qcallback);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.QueryCallback_Dispose");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.QueryCallback_Dispose");
  }

  return;
}

void ServerProcessor::process_QueryCallback_Success(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.QueryCallback_Success", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.QueryCallback_Success");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.QueryCallback_Success");
  }

  Server_QueryCallback_Success_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.QueryCallback_Success", bytes);
  }

  try {
    iface_->QueryCallback_Success(args.qcallback, args.response);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.QueryCallback_Success");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.QueryCallback_Success");
  }

  return;
}

void ServerProcessor::process_QueryCallback_Failure(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.QueryCallback_Failure", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.QueryCallback_Failure");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.QueryCallback_Failure");
  }

  Server_QueryCallback_Failure_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.QueryCallback_Failure", bytes);
  }

  try {
    iface_->QueryCallback_Failure(args.qcallback, args.error_code, args.error_message);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.QueryCallback_Failure");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.QueryCallback_Failure");
  }

  return;
}

void ServerProcessor::process_SchemeHandlerFactory_Register(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.SchemeHandlerFactory_Register", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.SchemeHandlerFactory_Register");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.SchemeHandlerFactory_Register");
  }

  Server_SchemeHandlerFactory_Register_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.SchemeHandlerFactory_Register", bytes);
  }

  try {
    iface_->SchemeHandlerFactory_Register(args.schemeName, args.domainName, args.schemeHandlerFactory);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.SchemeHandlerFactory_Register");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.SchemeHandlerFactory_Register");
  }

  return;
}

void ServerProcessor::process_ClearAllSchemeHandlerFactories(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.ClearAllSchemeHandlerFactories", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.ClearAllSchemeHandlerFactories");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.ClearAllSchemeHandlerFactories");
  }

  Server_ClearAllSchemeHandlerFactories_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.ClearAllSchemeHandlerFactories", bytes);
  }

  try {
    iface_->ClearAllSchemeHandlerFactories();
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.ClearAllSchemeHandlerFactories");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.ClearAllSchemeHandlerFactories");
  }

  return;
}

void ServerProcessor::process_RequestContext_ClearCertificateExceptions(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.RequestContext_ClearCertificateExceptions", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.RequestContext_ClearCertificateExceptions");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.RequestContext_ClearCertificateExceptions");
  }

  Server_RequestContext_ClearCertificateExceptions_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.RequestContext_ClearCertificateExceptions", bytes);
  }

  try {
    iface_->RequestContext_ClearCertificateExceptions(args.bid, args.completionCallback);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.RequestContext_ClearCertificateExceptions");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.RequestContext_ClearCertificateExceptions");
  }

  return;
}

void ServerProcessor::process_RequestContext_CloseAllConnections(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.RequestContext_CloseAllConnections", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.RequestContext_CloseAllConnections");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.RequestContext_CloseAllConnections");
  }

  Server_RequestContext_CloseAllConnections_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.RequestContext_CloseAllConnections", bytes);
  }

  try {
    iface_->RequestContext_CloseAllConnections(args.bid, args.completionCallback);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.RequestContext_CloseAllConnections");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.RequestContext_CloseAllConnections");
  }

  return;
}

void ServerProcessor::process_CookieManager_Create(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.CookieManager_Create", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.CookieManager_Create");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.CookieManager_Create");
  }

  Server_CookieManager_Create_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.CookieManager_Create", bytes);
  }

  Server_CookieManager_Create_result result;
  try {
    iface_->CookieManager_Create(result.success);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.CookieManager_Create");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("CookieManager_Create", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.CookieManager_Create");
  }

  oprot->writeMessageBegin("CookieManager_Create", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.CookieManager_Create", bytes);
  }
}

void ServerProcessor::process_CookieManager_Dispose(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.CookieManager_Dispose", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.CookieManager_Dispose");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.CookieManager_Dispose");
  }

  Server_CookieManager_Dispose_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.CookieManager_Dispose", bytes);
  }

  try {
    iface_->CookieManager_Dispose(args.cookieManager);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.CookieManager_Dispose");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.CookieManager_Dispose");
  }

  return;
}

void ServerProcessor::process_CookieManager_VisitAllCookies(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.CookieManager_VisitAllCookies", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.CookieManager_VisitAllCookies");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.CookieManager_VisitAllCookies");
  }

  Server_CookieManager_VisitAllCookies_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.CookieManager_VisitAllCookies", bytes);
  }

  Server_CookieManager_VisitAllCookies_result result;
  try {
    result.success = iface_->CookieManager_VisitAllCookies(args.cookieManager, args.visitor);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.CookieManager_VisitAllCookies");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("CookieManager_VisitAllCookies", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.CookieManager_VisitAllCookies");
  }

  oprot->writeMessageBegin("CookieManager_VisitAllCookies", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.CookieManager_VisitAllCookies", bytes);
  }
}

void ServerProcessor::process_CookieManager_VisitUrlCookies(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.CookieManager_VisitUrlCookies", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.CookieManager_VisitUrlCookies");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.CookieManager_VisitUrlCookies");
  }

  Server_CookieManager_VisitUrlCookies_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.CookieManager_VisitUrlCookies", bytes);
  }

  Server_CookieManager_VisitUrlCookies_result result;
  try {
    result.success = iface_->CookieManager_VisitUrlCookies(args.cookieManager, args.visitor, args.url, args.includeHttpOnly);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.CookieManager_VisitUrlCookies");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("CookieManager_VisitUrlCookies", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.CookieManager_VisitUrlCookies");
  }

  oprot->writeMessageBegin("CookieManager_VisitUrlCookies", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.CookieManager_VisitUrlCookies", bytes);
  }
}

void ServerProcessor::process_CookieManager_SetCookie(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.CookieManager_SetCookie", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.CookieManager_SetCookie");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.CookieManager_SetCookie");
  }

  Server_CookieManager_SetCookie_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.CookieManager_SetCookie", bytes);
  }

  Server_CookieManager_SetCookie_result result;
  try {
    result.success = iface_->CookieManager_SetCookie(args.cookieManager, args.url, args.cookie);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.CookieManager_SetCookie");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("CookieManager_SetCookie", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.CookieManager_SetCookie");
  }

  oprot->writeMessageBegin("CookieManager_SetCookie", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.CookieManager_SetCookie", bytes);
  }
}

void ServerProcessor::process_CookieManager_DeleteCookies(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.CookieManager_DeleteCookies", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.CookieManager_DeleteCookies");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.CookieManager_DeleteCookies");
  }

  Server_CookieManager_DeleteCookies_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.CookieManager_DeleteCookies", bytes);
  }

  Server_CookieManager_DeleteCookies_result result;
  try {
    result.success = iface_->CookieManager_DeleteCookies(args.cookieManager, args.url, args.cookieName);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.CookieManager_DeleteCookies");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("CookieManager_DeleteCookies", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.CookieManager_DeleteCookies");
  }

  oprot->writeMessageBegin("CookieManager_DeleteCookies", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.CookieManager_DeleteCookies", bytes);
  }
}

void ServerProcessor::process_CookieManager_FlushStore(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.CookieManager_FlushStore", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.CookieManager_FlushStore");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.CookieManager_FlushStore");
  }

  Server_CookieManager_FlushStore_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.CookieManager_FlushStore", bytes);
  }

  Server_CookieManager_FlushStore_result result;
  try {
    result.success = iface_->CookieManager_FlushStore(args.cookieManager, args.completionCallback);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.CookieManager_FlushStore");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("CookieManager_FlushStore", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.CookieManager_FlushStore");
  }

  oprot->writeMessageBegin("CookieManager_FlushStore", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.CookieManager_FlushStore", bytes);
  }
}

::std::shared_ptr< ::apache::thrift::TProcessor > ServerProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< ServerIfFactory > cleanup(handlerFactory_);
  ::std::shared_ptr< ServerIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::std::shared_ptr< ::apache::thrift::TProcessor > processor(new ServerProcessor(handler));
  return processor;
}

int32_t ServerConcurrentClient::connect(const std::string& backwardConnectionPipe, const bool isMaster)
{
  int32_t seqid = send_connect(backwardConnectionPipe, isMaster);
  return recv_connect(seqid);
}

int32_t ServerConcurrentClient::send_connect(const std::string& backwardConnectionPipe, const bool isMaster)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("connect", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_connect_pargs args;
  args.backwardConnectionPipe = &backwardConnectionPipe;
  args.isMaster = &isMaster;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t ServerConcurrentClient::recv_connect(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("connect") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      Server_connect_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "connect failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t ServerConcurrentClient::connectTcp(const int32_t backwardConnectionPort, const bool isMaster)
{
  int32_t seqid = send_connectTcp(backwardConnectionPort, isMaster);
  return recv_connectTcp(seqid);
}

int32_t ServerConcurrentClient::send_connectTcp(const int32_t backwardConnectionPort, const bool isMaster)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("connectTcp", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_connectTcp_pargs args;
  args.backwardConnectionPort = &backwardConnectionPort;
  args.isMaster = &isMaster;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t ServerConcurrentClient::recv_connectTcp(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("connectTcp") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      Server_connectTcp_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "connectTcp failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::log(const std::string& msg)
{
  send_log(msg);
}

void ServerConcurrentClient::send_log(const std::string& msg)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("log", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_log_pargs args;
  args.msg = &msg;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::echo(std::string& _return, const std::string& msg)
{
  int32_t seqid = send_echo(msg);
  recv_echo(_return, seqid);
}

int32_t ServerConcurrentClient::send_echo(const std::string& msg)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("echo", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_echo_pargs args;
  args.msg = &msg;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_echo(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("echo") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_echo_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "echo failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::version(std::string& _return)
{
  int32_t seqid = send_version();
  recv_version(_return, seqid);
}

int32_t ServerConcurrentClient::send_version()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("version", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_version_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_version(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("version") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_version_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "version failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::state(std::string& _return)
{
  int32_t seqid = send_state();
  recv_state(_return, seqid);
}

int32_t ServerConcurrentClient::send_state()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("state", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_state_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_state(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("state") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_state_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "state failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::stop()
{
  send_stop();
}

void ServerConcurrentClient::send_stop()
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("stop", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_stop_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

int32_t ServerConcurrentClient::Browser_Create(const int32_t cid, const int32_t handlersMask, const  ::thrift_codegen::RObject& requestContextHandler)
{
  int32_t seqid = send_Browser_Create(cid, handlersMask, requestContextHandler);
  return recv_Browser_Create(seqid);
}

int32_t ServerConcurrentClient::send_Browser_Create(const int32_t cid, const int32_t handlersMask, const  ::thrift_codegen::RObject& requestContextHandler)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_Create", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_Create_pargs args;
  args.cid = &cid;
  args.handlersMask = &handlersMask;
  args.requestContextHandler = &requestContextHandler;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t ServerConcurrentClient::recv_Browser_Create(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Browser_Create") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      Server_Browser_Create_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_Create failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Browser_StartNativeCreation(const int32_t bid, const std::string& url)
{
  send_Browser_StartNativeCreation(bid, url);
}

void ServerConcurrentClient::send_Browser_StartNativeCreation(const int32_t bid, const std::string& url)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_StartNativeCreation", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_StartNativeCreation_pargs args;
  args.bid = &bid;
  args.url = &url;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Browser_Close(const int32_t bid)
{
  send_Browser_Close(bid);
}

void ServerConcurrentClient::send_Browser_Close(const int32_t bid)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_Close", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_Close_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Browser_Reload(const int32_t bid)
{
  send_Browser_Reload(bid);
}

void ServerConcurrentClient::send_Browser_Reload(const int32_t bid)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_Reload", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_Reload_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Browser_ReloadIgnoreCache(const int32_t bid)
{
  send_Browser_ReloadIgnoreCache(bid);
}

void ServerConcurrentClient::send_Browser_ReloadIgnoreCache(const int32_t bid)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_ReloadIgnoreCache", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_ReloadIgnoreCache_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Browser_LoadURL(const int32_t bid, const std::string& url)
{
  send_Browser_LoadURL(bid, url);
}

void ServerConcurrentClient::send_Browser_LoadURL(const int32_t bid, const std::string& url)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_LoadURL", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_LoadURL_pargs args;
  args.bid = &bid;
  args.url = &url;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Browser_LoadRequest(const int32_t bid, const  ::thrift_codegen::RObject& request)
{
  send_Browser_LoadRequest(bid, request);
}

void ServerConcurrentClient::send_Browser_LoadRequest(const int32_t bid, const  ::thrift_codegen::RObject& request)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_LoadRequest", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_LoadRequest_pargs args;
  args.bid = &bid;
  args.request = &request;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Browser_GetURL(std::string& _return, const int32_t bid)
{
  int32_t seqid = send_Browser_GetURL(bid);
  recv_Browser_GetURL(_return, seqid);
}

int32_t ServerConcurrentClient::send_Browser_GetURL(const int32_t bid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_GetURL", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_GetURL_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Browser_GetURL(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Browser_GetURL") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Browser_GetURL_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_GetURL failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Browser_ExecuteJavaScript(const int32_t bid, const std::string& code, const std::string& url, const int32_t line)
{
  send_Browser_ExecuteJavaScript(bid, code, url, line);
}

void ServerConcurrentClient::send_Browser_ExecuteJavaScript(const int32_t bid, const std::string& code, const std::string& url, const int32_t line)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_ExecuteJavaScript", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_ExecuteJavaScript_pargs args;
  args.bid = &bid;
  args.code = &code;
  args.url = &url;
  args.line = &line;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Browser_WasResized(const int32_t bid)
{
  send_Browser_WasResized(bid);
}

void ServerConcurrentClient::send_Browser_WasResized(const int32_t bid)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_WasResized", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_WasResized_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Browser_NotifyScreenInfoChanged(const int32_t bid)
{
  send_Browser_NotifyScreenInfoChanged(bid);
}

void ServerConcurrentClient::send_Browser_NotifyScreenInfoChanged(const int32_t bid)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_NotifyScreenInfoChanged", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_NotifyScreenInfoChanged_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Browser_SendKeyEvent(const int32_t bid, const int32_t event_type, const int32_t modifiers, const int16_t key_char, const int64_t scanCode, const int32_t key_code)
{
  send_Browser_SendKeyEvent(bid, event_type, modifiers, key_char, scanCode, key_code);
}

void ServerConcurrentClient::send_Browser_SendKeyEvent(const int32_t bid, const int32_t event_type, const int32_t modifiers, const int16_t key_char, const int64_t scanCode, const int32_t key_code)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_SendKeyEvent", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_SendKeyEvent_pargs args;
  args.bid = &bid;
  args.event_type = &event_type;
  args.modifiers = &modifiers;
  args.key_char = &key_char;
  args.scanCode = &scanCode;
  args.key_code = &key_code;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Browser_SendMouseEvent(const int32_t bid, const int32_t event_type, const int32_t x, const int32_t y, const int32_t modifiers, const int32_t click_count, const int32_t button)
{
  send_Browser_SendMouseEvent(bid, event_type, x, y, modifiers, click_count, button);
}

void ServerConcurrentClient::send_Browser_SendMouseEvent(const int32_t bid, const int32_t event_type, const int32_t x, const int32_t y, const int32_t modifiers, const int32_t click_count, const int32_t button)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_SendMouseEvent", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_SendMouseEvent_pargs args;
  args.bid = &bid;
  args.event_type = &event_type;
  args.x = &x;
  args.y = &y;
  args.modifiers = &modifiers;
  args.click_count = &click_count;
  args.button = &button;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Browser_SendMouseWheelEvent(const int32_t bid, const int32_t scroll_type, const int32_t x, const int32_t y, const int32_t modifiers, const int32_t delta, const int32_t units_to_scroll)
{
  send_Browser_SendMouseWheelEvent(bid, scroll_type, x, y, modifiers, delta, units_to_scroll);
}

void ServerConcurrentClient::send_Browser_SendMouseWheelEvent(const int32_t bid, const int32_t scroll_type, const int32_t x, const int32_t y, const int32_t modifiers, const int32_t delta, const int32_t units_to_scroll)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_SendMouseWheelEvent", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_SendMouseWheelEvent_pargs args;
  args.bid = &bid;
  args.scroll_type = &scroll_type;
  args.x = &x;
  args.y = &y;
  args.modifiers = &modifiers;
  args.delta = &delta;
  args.units_to_scroll = &units_to_scroll;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

bool ServerConcurrentClient::Browser_CanGoForward(const int32_t bid)
{
  int32_t seqid = send_Browser_CanGoForward(bid);
  return recv_Browser_CanGoForward(seqid);
}

int32_t ServerConcurrentClient::send_Browser_CanGoForward(const int32_t bid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_CanGoForward", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_CanGoForward_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool ServerConcurrentClient::recv_Browser_CanGoForward(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Browser_CanGoForward") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      Server_Browser_CanGoForward_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_CanGoForward failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

bool ServerConcurrentClient::Browser_CanGoBack(const int32_t bid)
{
  int32_t seqid = send_Browser_CanGoBack(bid);
  return recv_Browser_CanGoBack(seqid);
}

int32_t ServerConcurrentClient::send_Browser_CanGoBack(const int32_t bid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_CanGoBack", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_CanGoBack_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool ServerConcurrentClient::recv_Browser_CanGoBack(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Browser_CanGoBack") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      Server_Browser_CanGoBack_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_CanGoBack failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Browser_GoBack(const int32_t bid)
{
  send_Browser_GoBack(bid);
}

void ServerConcurrentClient::send_Browser_GoBack(const int32_t bid)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_GoBack", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_GoBack_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Browser_GoForward(const int32_t bid)
{
  send_Browser_GoForward(bid);
}

void ServerConcurrentClient::send_Browser_GoForward(const int32_t bid)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_GoForward", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_GoForward_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

bool ServerConcurrentClient::Browser_IsLoading(const int32_t bid)
{
  int32_t seqid = send_Browser_IsLoading(bid);
  return recv_Browser_IsLoading(seqid);
}

int32_t ServerConcurrentClient::send_Browser_IsLoading(const int32_t bid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_IsLoading", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_IsLoading_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool ServerConcurrentClient::recv_Browser_IsLoading(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Browser_IsLoading") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      Server_Browser_IsLoading_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_IsLoading failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Browser_StopLoad(const int32_t bid)
{
  send_Browser_StopLoad(bid);
}

void ServerConcurrentClient::send_Browser_StopLoad(const int32_t bid)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_StopLoad", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_StopLoad_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Browser_GetMainFrame( ::thrift_codegen::RObject& _return, const int32_t bid)
{
  int32_t seqid = send_Browser_GetMainFrame(bid);
  recv_Browser_GetMainFrame(_return, seqid);
}

int32_t ServerConcurrentClient::send_Browser_GetMainFrame(const int32_t bid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_GetMainFrame", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_GetMainFrame_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Browser_GetMainFrame( ::thrift_codegen::RObject& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Browser_GetMainFrame") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Browser_GetMainFrame_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_GetMainFrame failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Browser_GetFocusedFrame( ::thrift_codegen::RObject& _return, const int32_t bid)
{
  int32_t seqid = send_Browser_GetFocusedFrame(bid);
  recv_Browser_GetFocusedFrame(_return, seqid);
}

int32_t ServerConcurrentClient::send_Browser_GetFocusedFrame(const int32_t bid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_GetFocusedFrame", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_GetFocusedFrame_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Browser_GetFocusedFrame( ::thrift_codegen::RObject& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Browser_GetFocusedFrame") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Browser_GetFocusedFrame_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_GetFocusedFrame failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Browser_GetFrameByIdentifier( ::thrift_codegen::RObject& _return, const int32_t bid, const std::string& identifier)
{
  int32_t seqid = send_Browser_GetFrameByIdentifier(bid, identifier);
  recv_Browser_GetFrameByIdentifier(_return, seqid);
}

int32_t ServerConcurrentClient::send_Browser_GetFrameByIdentifier(const int32_t bid, const std::string& identifier)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_GetFrameByIdentifier", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_GetFrameByIdentifier_pargs args;
  args.bid = &bid;
  args.identifier = &identifier;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Browser_GetFrameByIdentifier( ::thrift_codegen::RObject& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Browser_GetFrameByIdentifier") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Browser_GetFrameByIdentifier_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_GetFrameByIdentifier failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Browser_GetFrameByName( ::thrift_codegen::RObject& _return, const int32_t bid, const std::string& name)
{
  int32_t seqid = send_Browser_GetFrameByName(bid, name);
  recv_Browser_GetFrameByName(_return, seqid);
}

int32_t ServerConcurrentClient::send_Browser_GetFrameByName(const int32_t bid, const std::string& name)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_GetFrameByName", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_GetFrameByName_pargs args;
  args.bid = &bid;
  args.name = &name;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Browser_GetFrameByName( ::thrift_codegen::RObject& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Browser_GetFrameByName") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Browser_GetFrameByName_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_GetFrameByName failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t ServerConcurrentClient::Browser_GetFrameCount(const int32_t bid)
{
  int32_t seqid = send_Browser_GetFrameCount(bid);
  return recv_Browser_GetFrameCount(seqid);
}

int32_t ServerConcurrentClient::send_Browser_GetFrameCount(const int32_t bid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_GetFrameCount", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_GetFrameCount_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t ServerConcurrentClient::recv_Browser_GetFrameCount(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Browser_GetFrameCount") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      Server_Browser_GetFrameCount_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_GetFrameCount failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Browser_GetFrameIdentifiers(std::vector<std::string> & _return, const int32_t bid)
{
  int32_t seqid = send_Browser_GetFrameIdentifiers(bid);
  recv_Browser_GetFrameIdentifiers(_return, seqid);
}

int32_t ServerConcurrentClient::send_Browser_GetFrameIdentifiers(const int32_t bid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_GetFrameIdentifiers", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_GetFrameIdentifiers_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Browser_GetFrameIdentifiers(std::vector<std::string> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Browser_GetFrameIdentifiers") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Browser_GetFrameIdentifiers_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_GetFrameIdentifiers failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Browser_GetFrameNames(std::vector<std::string> & _return, const int32_t bid)
{
  int32_t seqid = send_Browser_GetFrameNames(bid);
  recv_Browser_GetFrameNames(_return, seqid);
}

int32_t ServerConcurrentClient::send_Browser_GetFrameNames(const int32_t bid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_GetFrameNames", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_GetFrameNames_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Browser_GetFrameNames(std::vector<std::string> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Browser_GetFrameNames") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Browser_GetFrameNames_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_GetFrameNames failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

bool ServerConcurrentClient::Browser_IsPopup(const int32_t bid)
{
  int32_t seqid = send_Browser_IsPopup(bid);
  return recv_Browser_IsPopup(seqid);
}

int32_t ServerConcurrentClient::send_Browser_IsPopup(const int32_t bid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_IsPopup", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_IsPopup_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool ServerConcurrentClient::recv_Browser_IsPopup(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Browser_IsPopup") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      Server_Browser_IsPopup_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_IsPopup failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

bool ServerConcurrentClient::Browser_HasDocument(const int32_t bid)
{
  int32_t seqid = send_Browser_HasDocument(bid);
  return recv_Browser_HasDocument(seqid);
}

int32_t ServerConcurrentClient::send_Browser_HasDocument(const int32_t bid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_HasDocument", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_HasDocument_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool ServerConcurrentClient::recv_Browser_HasDocument(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Browser_HasDocument") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      Server_Browser_HasDocument_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_HasDocument failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Browser_ViewSource(const int32_t bid)
{
  send_Browser_ViewSource(bid);
}

void ServerConcurrentClient::send_Browser_ViewSource(const int32_t bid)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_ViewSource", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_ViewSource_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Browser_GetSource(const int32_t bid, const  ::thrift_codegen::RObject& stringVisitor)
{
  send_Browser_GetSource(bid, stringVisitor);
}

void ServerConcurrentClient::send_Browser_GetSource(const int32_t bid, const  ::thrift_codegen::RObject& stringVisitor)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_GetSource", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_GetSource_pargs args;
  args.bid = &bid;
  args.stringVisitor = &stringVisitor;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Browser_GetText(const int32_t bid, const  ::thrift_codegen::RObject& stringVisitor)
{
  send_Browser_GetText(bid, stringVisitor);
}

void ServerConcurrentClient::send_Browser_GetText(const int32_t bid, const  ::thrift_codegen::RObject& stringVisitor)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_GetText", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_GetText_pargs args;
  args.bid = &bid;
  args.stringVisitor = &stringVisitor;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Browser_SetFocus(const int32_t bid, const bool enable)
{
  send_Browser_SetFocus(bid, enable);
}

void ServerConcurrentClient::send_Browser_SetFocus(const int32_t bid, const bool enable)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_SetFocus", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_SetFocus_pargs args;
  args.bid = &bid;
  args.enable = &enable;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

double ServerConcurrentClient::Browser_GetZoomLevel(const int32_t bid)
{
  int32_t seqid = send_Browser_GetZoomLevel(bid);
  return recv_Browser_GetZoomLevel(seqid);
}

int32_t ServerConcurrentClient::send_Browser_GetZoomLevel(const int32_t bid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_GetZoomLevel", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_GetZoomLevel_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

double ServerConcurrentClient::recv_Browser_GetZoomLevel(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Browser_GetZoomLevel") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      double _return;
      Server_Browser_GetZoomLevel_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_GetZoomLevel failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Browser_SetZoomLevel(const int32_t bid, const double val)
{
  send_Browser_SetZoomLevel(bid, val);
}

void ServerConcurrentClient::send_Browser_SetZoomLevel(const int32_t bid, const double val)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_SetZoomLevel", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_SetZoomLevel_pargs args;
  args.bid = &bid;
  args.val = &val;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Browser_StartDownload(const int32_t bid, const std::string& url)
{
  send_Browser_StartDownload(bid, url);
}

void ServerConcurrentClient::send_Browser_StartDownload(const int32_t bid, const std::string& url)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_StartDownload", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_StartDownload_pargs args;
  args.bid = &bid;
  args.url = &url;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Browser_Find(const int32_t bid, const std::string& searchText, const bool forward, const bool matchCase, const bool findNext)
{
  send_Browser_Find(bid, searchText, forward, matchCase, findNext);
}

void ServerConcurrentClient::send_Browser_Find(const int32_t bid, const std::string& searchText, const bool forward, const bool matchCase, const bool findNext)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_Find", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_Find_pargs args;
  args.bid = &bid;
  args.searchText = &searchText;
  args.forward = &forward;
  args.matchCase = &matchCase;
  args.findNext = &findNext;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Browser_StopFinding(const int32_t bid, const bool clearSelection)
{
  send_Browser_StopFinding(bid, clearSelection);
}

void ServerConcurrentClient::send_Browser_StopFinding(const int32_t bid, const bool clearSelection)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_StopFinding", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_StopFinding_pargs args;
  args.bid = &bid;
  args.clearSelection = &clearSelection;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Browser_ReplaceMisspelling(const int32_t bid, const std::string& word)
{
  send_Browser_ReplaceMisspelling(bid, word);
}

void ServerConcurrentClient::send_Browser_ReplaceMisspelling(const int32_t bid, const std::string& word)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_ReplaceMisspelling", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_ReplaceMisspelling_pargs args;
  args.bid = &bid;
  args.word = &word;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Browser_SetFrameRate(const int32_t bid, const int32_t val)
{
  send_Browser_SetFrameRate(bid, val);
}

void ServerConcurrentClient::send_Browser_SetFrameRate(const int32_t bid, const int32_t val)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_SetFrameRate", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_SetFrameRate_pargs args;
  args.bid = &bid;
  args.val = &val;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Frame_ExecuteJavaScript(const int32_t frameId, const std::string& code, const std::string& url, const int32_t line)
{
  send_Frame_ExecuteJavaScript(frameId, code, url, line);
}

void ServerConcurrentClient::send_Frame_ExecuteJavaScript(const int32_t frameId, const std::string& code, const std::string& url, const int32_t line)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Frame_ExecuteJavaScript", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Frame_ExecuteJavaScript_pargs args;
  args.frameId = &frameId;
  args.code = &code;
  args.url = &url;
  args.line = &line;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Frame_Dispose(const int32_t frameId)
{
  send_Frame_Dispose(frameId);
}

void ServerConcurrentClient::send_Frame_Dispose(const int32_t frameId)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Frame_Dispose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Frame_Dispose_pargs args;
  args.frameId = &frameId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Frame_GetParent( ::thrift_codegen::RObject& _return, const int32_t frameId)
{
  int32_t seqid = send_Frame_GetParent(frameId);
  recv_Frame_GetParent(_return, seqid);
}

int32_t ServerConcurrentClient::send_Frame_GetParent(const int32_t frameId)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Frame_GetParent", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Frame_GetParent_pargs args;
  args.frameId = &frameId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Frame_GetParent( ::thrift_codegen::RObject& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Frame_GetParent") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Frame_GetParent_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Frame_GetParent failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Frame_Undo(const int32_t frameId)
{
  send_Frame_Undo(frameId);
}

void ServerConcurrentClient::send_Frame_Undo(const int32_t frameId)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Frame_Undo", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Frame_Undo_pargs args;
  args.frameId = &frameId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Frame_Redo(const int32_t frameId)
{
  send_Frame_Redo(frameId);
}

void ServerConcurrentClient::send_Frame_Redo(const int32_t frameId)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Frame_Redo", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Frame_Redo_pargs args;
  args.frameId = &frameId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Frame_Cut(const int32_t frameId)
{
  send_Frame_Cut(frameId);
}

void ServerConcurrentClient::send_Frame_Cut(const int32_t frameId)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Frame_Cut", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Frame_Cut_pargs args;
  args.frameId = &frameId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Frame_Copy(const int32_t frameId)
{
  send_Frame_Copy(frameId);
}

void ServerConcurrentClient::send_Frame_Copy(const int32_t frameId)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Frame_Copy", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Frame_Copy_pargs args;
  args.frameId = &frameId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Frame_Paste(const int32_t frameId)
{
  send_Frame_Paste(frameId);
}

void ServerConcurrentClient::send_Frame_Paste(const int32_t frameId)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Frame_Paste", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Frame_Paste_pargs args;
  args.frameId = &frameId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Frame_Delete(const int32_t frameId)
{
  send_Frame_Delete(frameId);
}

void ServerConcurrentClient::send_Frame_Delete(const int32_t frameId)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Frame_Delete", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Frame_Delete_pargs args;
  args.frameId = &frameId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Frame_SelectAll(const int32_t frameId)
{
  send_Frame_SelectAll(frameId);
}

void ServerConcurrentClient::send_Frame_SelectAll(const int32_t frameId)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Frame_SelectAll", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Frame_SelectAll_pargs args;
  args.frameId = &frameId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Request_Create( ::thrift_codegen::RObject& _return)
{
  int32_t seqid = send_Request_Create();
  recv_Request_Create(_return, seqid);
}

int32_t ServerConcurrentClient::send_Request_Create()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Request_Create", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_Create_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Request_Create( ::thrift_codegen::RObject& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Request_Create") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Request_Create_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Request_Create failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Request_Dispose(const int32_t requestId)
{
  send_Request_Dispose(requestId);
}

void ServerConcurrentClient::send_Request_Dispose(const int32_t requestId)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Request_Dispose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Request_Dispose_pargs args;
  args.requestId = &requestId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Request_Update(const  ::thrift_codegen::RObject& request)
{
  int32_t seqid = send_Request_Update(request);
  recv_Request_Update(seqid);
}

int32_t ServerConcurrentClient::send_Request_Update(const  ::thrift_codegen::RObject& request)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Request_Update", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_Update_pargs args;
  args.request = &request;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Request_Update(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Request_Update") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Request_Update_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Request_GetPostData( ::thrift_codegen::PostData& _return, const  ::thrift_codegen::RObject& request)
{
  int32_t seqid = send_Request_GetPostData(request);
  recv_Request_GetPostData(_return, seqid);
}

int32_t ServerConcurrentClient::send_Request_GetPostData(const  ::thrift_codegen::RObject& request)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Request_GetPostData", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_GetPostData_pargs args;
  args.request = &request;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Request_GetPostData( ::thrift_codegen::PostData& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Request_GetPostData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Request_GetPostData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Request_GetPostData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Request_SetPostData(const  ::thrift_codegen::RObject& request, const  ::thrift_codegen::PostData& postData)
{
  int32_t seqid = send_Request_SetPostData(request, postData);
  recv_Request_SetPostData(seqid);
}

int32_t ServerConcurrentClient::send_Request_SetPostData(const  ::thrift_codegen::RObject& request, const  ::thrift_codegen::PostData& postData)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Request_SetPostData", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_SetPostData_pargs args;
  args.request = &request;
  args.postData = &postData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Request_SetPostData(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Request_SetPostData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Request_SetPostData_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Request_GetHeaderByName(std::string& _return, const  ::thrift_codegen::RObject& request, const std::string& name)
{
  int32_t seqid = send_Request_GetHeaderByName(request, name);
  recv_Request_GetHeaderByName(_return, seqid);
}

int32_t ServerConcurrentClient::send_Request_GetHeaderByName(const  ::thrift_codegen::RObject& request, const std::string& name)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Request_GetHeaderByName", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_GetHeaderByName_pargs args;
  args.request = &request;
  args.name = &name;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Request_GetHeaderByName(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Request_GetHeaderByName") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Request_GetHeaderByName_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Request_GetHeaderByName failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Request_SetHeaderByName(const  ::thrift_codegen::RObject& request, const std::string& name, const std::string& value, const bool overwrite)
{
  int32_t seqid = send_Request_SetHeaderByName(request, name, value, overwrite);
  recv_Request_SetHeaderByName(seqid);
}

int32_t ServerConcurrentClient::send_Request_SetHeaderByName(const  ::thrift_codegen::RObject& request, const std::string& name, const std::string& value, const bool overwrite)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Request_SetHeaderByName", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_SetHeaderByName_pargs args;
  args.request = &request;
  args.name = &name;
  args.value = &value;
  args.overwrite = &overwrite;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Request_SetHeaderByName(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Request_SetHeaderByName") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Request_SetHeaderByName_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Request_GetHeaderMap(std::map<std::string, std::string> & _return, const  ::thrift_codegen::RObject& request)
{
  int32_t seqid = send_Request_GetHeaderMap(request);
  recv_Request_GetHeaderMap(_return, seqid);
}

int32_t ServerConcurrentClient::send_Request_GetHeaderMap(const  ::thrift_codegen::RObject& request)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Request_GetHeaderMap", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_GetHeaderMap_pargs args;
  args.request = &request;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Request_GetHeaderMap(std::map<std::string, std::string> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Request_GetHeaderMap") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Request_GetHeaderMap_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Request_GetHeaderMap failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Request_SetHeaderMap(const  ::thrift_codegen::RObject& request, const std::map<std::string, std::string> & headerMap)
{
  int32_t seqid = send_Request_SetHeaderMap(request, headerMap);
  recv_Request_SetHeaderMap(seqid);
}

int32_t ServerConcurrentClient::send_Request_SetHeaderMap(const  ::thrift_codegen::RObject& request, const std::map<std::string, std::string> & headerMap)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Request_SetHeaderMap", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_SetHeaderMap_pargs args;
  args.request = &request;
  args.headerMap = &headerMap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Request_SetHeaderMap(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Request_SetHeaderMap") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Request_SetHeaderMap_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Request_Set(const  ::thrift_codegen::RObject& request, const std::string& url, const std::string& method, const  ::thrift_codegen::PostData& postData, const std::map<std::string, std::string> & headerMap)
{
  int32_t seqid = send_Request_Set(request, url, method, postData, headerMap);
  recv_Request_Set(seqid);
}

int32_t ServerConcurrentClient::send_Request_Set(const  ::thrift_codegen::RObject& request, const std::string& url, const std::string& method, const  ::thrift_codegen::PostData& postData, const std::map<std::string, std::string> & headerMap)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Request_Set", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_Set_pargs args;
  args.request = &request;
  args.url = &url;
  args.method = &method;
  args.postData = &postData;
  args.headerMap = &headerMap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Request_Set(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Request_Set") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Request_Set_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Response_Update(const  ::thrift_codegen::RObject& response)
{
  int32_t seqid = send_Response_Update(response);
  recv_Response_Update(seqid);
}

int32_t ServerConcurrentClient::send_Response_Update(const  ::thrift_codegen::RObject& response)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Response_Update", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Response_Update_pargs args;
  args.response = &response;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Response_Update(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Response_Update") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Response_Update_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Response_GetHeaderByName(std::string& _return, const  ::thrift_codegen::RObject& response, const std::string& name)
{
  int32_t seqid = send_Response_GetHeaderByName(response, name);
  recv_Response_GetHeaderByName(_return, seqid);
}

int32_t ServerConcurrentClient::send_Response_GetHeaderByName(const  ::thrift_codegen::RObject& response, const std::string& name)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Response_GetHeaderByName", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Response_GetHeaderByName_pargs args;
  args.response = &response;
  args.name = &name;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Response_GetHeaderByName(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Response_GetHeaderByName") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Response_GetHeaderByName_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Response_GetHeaderByName failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Response_SetHeaderByName(const  ::thrift_codegen::RObject& response, const std::string& name, const std::string& value, const bool overwrite)
{
  int32_t seqid = send_Response_SetHeaderByName(response, name, value, overwrite);
  recv_Response_SetHeaderByName(seqid);
}

int32_t ServerConcurrentClient::send_Response_SetHeaderByName(const  ::thrift_codegen::RObject& response, const std::string& name, const std::string& value, const bool overwrite)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Response_SetHeaderByName", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Response_SetHeaderByName_pargs args;
  args.response = &response;
  args.name = &name;
  args.value = &value;
  args.overwrite = &overwrite;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Response_SetHeaderByName(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Response_SetHeaderByName") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Response_SetHeaderByName_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Response_GetHeaderMap(std::map<std::string, std::string> & _return, const  ::thrift_codegen::RObject& response)
{
  int32_t seqid = send_Response_GetHeaderMap(response);
  recv_Response_GetHeaderMap(_return, seqid);
}

int32_t ServerConcurrentClient::send_Response_GetHeaderMap(const  ::thrift_codegen::RObject& response)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Response_GetHeaderMap", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Response_GetHeaderMap_pargs args;
  args.response = &response;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Response_GetHeaderMap(std::map<std::string, std::string> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Response_GetHeaderMap") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Response_GetHeaderMap_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Response_GetHeaderMap failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Response_SetHeaderMap(const  ::thrift_codegen::RObject& response, const std::map<std::string, std::string> & headerMap)
{
  int32_t seqid = send_Response_SetHeaderMap(response, headerMap);
  recv_Response_SetHeaderMap(seqid);
}

int32_t ServerConcurrentClient::send_Response_SetHeaderMap(const  ::thrift_codegen::RObject& response, const std::map<std::string, std::string> & headerMap)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Response_SetHeaderMap", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Response_SetHeaderMap_pargs args;
  args.response = &response;
  args.headerMap = &headerMap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Response_SetHeaderMap(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Response_SetHeaderMap") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Response_SetHeaderMap_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Callback_Dispose(const  ::thrift_codegen::RObject& callback)
{
  send_Callback_Dispose(callback);
}

void ServerConcurrentClient::send_Callback_Dispose(const  ::thrift_codegen::RObject& callback)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Callback_Dispose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Callback_Dispose_pargs args;
  args.callback = &callback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Callback_Continue(const  ::thrift_codegen::RObject& callback)
{
  send_Callback_Continue(callback);
}

void ServerConcurrentClient::send_Callback_Continue(const  ::thrift_codegen::RObject& callback)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Callback_Continue", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Callback_Continue_pargs args;
  args.callback = &callback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Callback_Cancel(const  ::thrift_codegen::RObject& callback)
{
  send_Callback_Cancel(callback);
}

void ServerConcurrentClient::send_Callback_Cancel(const  ::thrift_codegen::RObject& callback)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Callback_Cancel", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Callback_Cancel_pargs args;
  args.callback = &callback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::AuthCallback_Dispose(const  ::thrift_codegen::RObject& authCallback)
{
  send_AuthCallback_Dispose(authCallback);
}

void ServerConcurrentClient::send_AuthCallback_Dispose(const  ::thrift_codegen::RObject& authCallback)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("AuthCallback_Dispose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_AuthCallback_Dispose_pargs args;
  args.authCallback = &authCallback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::AuthCallback_Continue(const  ::thrift_codegen::RObject& authCallback, const std::string& username, const std::string& password)
{
  send_AuthCallback_Continue(authCallback, username, password);
}

void ServerConcurrentClient::send_AuthCallback_Continue(const  ::thrift_codegen::RObject& authCallback, const std::string& username, const std::string& password)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("AuthCallback_Continue", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_AuthCallback_Continue_pargs args;
  args.authCallback = &authCallback;
  args.username = &username;
  args.password = &password;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::AuthCallback_Cancel(const  ::thrift_codegen::RObject& authCallback)
{
  send_AuthCallback_Cancel(authCallback);
}

void ServerConcurrentClient::send_AuthCallback_Cancel(const  ::thrift_codegen::RObject& authCallback)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("AuthCallback_Cancel", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_AuthCallback_Cancel_pargs args;
  args.authCallback = &authCallback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::MessageRouter_Create( ::thrift_codegen::RObject& _return, const std::string& query, const std::string& cancel)
{
  int32_t seqid = send_MessageRouter_Create(query, cancel);
  recv_MessageRouter_Create(_return, seqid);
}

int32_t ServerConcurrentClient::send_MessageRouter_Create(const std::string& query, const std::string& cancel)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("MessageRouter_Create", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_MessageRouter_Create_pargs args;
  args.query = &query;
  args.cancel = &cancel;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_MessageRouter_Create( ::thrift_codegen::RObject& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("MessageRouter_Create") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_MessageRouter_Create_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "MessageRouter_Create failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::MessageRouter_Dispose(const  ::thrift_codegen::RObject& msgRouter)
{
  send_MessageRouter_Dispose(msgRouter);
}

void ServerConcurrentClient::send_MessageRouter_Dispose(const  ::thrift_codegen::RObject& msgRouter)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("MessageRouter_Dispose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_MessageRouter_Dispose_pargs args;
  args.msgRouter = &msgRouter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::MessageRouter_AddMessageRouterToBrowser(const  ::thrift_codegen::RObject& msgRouter, const int32_t bid)
{
  int32_t seqid = send_MessageRouter_AddMessageRouterToBrowser(msgRouter, bid);
  recv_MessageRouter_AddMessageRouterToBrowser(seqid);
}

int32_t ServerConcurrentClient::send_MessageRouter_AddMessageRouterToBrowser(const  ::thrift_codegen::RObject& msgRouter, const int32_t bid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("MessageRouter_AddMessageRouterToBrowser", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_MessageRouter_AddMessageRouterToBrowser_pargs args;
  args.msgRouter = &msgRouter;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_MessageRouter_AddMessageRouterToBrowser(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("MessageRouter_AddMessageRouterToBrowser") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_MessageRouter_AddMessageRouterToBrowser_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::MessageRouter_RemoveMessageRouterFromBrowser(const  ::thrift_codegen::RObject& msgRouter, const int32_t bid)
{
  int32_t seqid = send_MessageRouter_RemoveMessageRouterFromBrowser(msgRouter, bid);
  recv_MessageRouter_RemoveMessageRouterFromBrowser(seqid);
}

int32_t ServerConcurrentClient::send_MessageRouter_RemoveMessageRouterFromBrowser(const  ::thrift_codegen::RObject& msgRouter, const int32_t bid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("MessageRouter_RemoveMessageRouterFromBrowser", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_MessageRouter_RemoveMessageRouterFromBrowser_pargs args;
  args.msgRouter = &msgRouter;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_MessageRouter_RemoveMessageRouterFromBrowser(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("MessageRouter_RemoveMessageRouterFromBrowser") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_MessageRouter_RemoveMessageRouterFromBrowser_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::MessageRouter_AddHandler(const  ::thrift_codegen::RObject& msgRouter, const  ::thrift_codegen::RObject& handler, const bool first)
{
  int32_t seqid = send_MessageRouter_AddHandler(msgRouter, handler, first);
  recv_MessageRouter_AddHandler(seqid);
}

int32_t ServerConcurrentClient::send_MessageRouter_AddHandler(const  ::thrift_codegen::RObject& msgRouter, const  ::thrift_codegen::RObject& handler, const bool first)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("MessageRouter_AddHandler", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_MessageRouter_AddHandler_pargs args;
  args.msgRouter = &msgRouter;
  args.handler = &handler;
  args.first = &first;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_MessageRouter_AddHandler(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("MessageRouter_AddHandler") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_MessageRouter_AddHandler_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::MessageRouter_RemoveHandler(const  ::thrift_codegen::RObject& msgRouter, const  ::thrift_codegen::RObject& handler)
{
  int32_t seqid = send_MessageRouter_RemoveHandler(msgRouter, handler);
  recv_MessageRouter_RemoveHandler(seqid);
}

int32_t ServerConcurrentClient::send_MessageRouter_RemoveHandler(const  ::thrift_codegen::RObject& msgRouter, const  ::thrift_codegen::RObject& handler)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("MessageRouter_RemoveHandler", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_MessageRouter_RemoveHandler_pargs args;
  args.msgRouter = &msgRouter;
  args.handler = &handler;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_MessageRouter_RemoveHandler(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("MessageRouter_RemoveHandler") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_MessageRouter_RemoveHandler_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::MessageRouter_CancelPending(const  ::thrift_codegen::RObject& msgRouter, const int32_t bid, const  ::thrift_codegen::RObject& handler)
{
  int32_t seqid = send_MessageRouter_CancelPending(msgRouter, bid, handler);
  recv_MessageRouter_CancelPending(seqid);
}

int32_t ServerConcurrentClient::send_MessageRouter_CancelPending(const  ::thrift_codegen::RObject& msgRouter, const int32_t bid, const  ::thrift_codegen::RObject& handler)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("MessageRouter_CancelPending", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_MessageRouter_CancelPending_pargs args;
  args.msgRouter = &msgRouter;
  args.bid = &bid;
  args.handler = &handler;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_MessageRouter_CancelPending(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("MessageRouter_CancelPending") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_MessageRouter_CancelPending_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::QueryCallback_Dispose(const  ::thrift_codegen::RObject& qcallback)
{
  send_QueryCallback_Dispose(qcallback);
}

void ServerConcurrentClient::send_QueryCallback_Dispose(const  ::thrift_codegen::RObject& qcallback)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("QueryCallback_Dispose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_QueryCallback_Dispose_pargs args;
  args.qcallback = &qcallback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::QueryCallback_Success(const  ::thrift_codegen::RObject& qcallback, const std::string& response)
{
  send_QueryCallback_Success(qcallback, response);
}

void ServerConcurrentClient::send_QueryCallback_Success(const  ::thrift_codegen::RObject& qcallback, const std::string& response)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("QueryCallback_Success", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_QueryCallback_Success_pargs args;
  args.qcallback = &qcallback;
  args.response = &response;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::QueryCallback_Failure(const  ::thrift_codegen::RObject& qcallback, const int32_t error_code, const std::string& error_message)
{
  send_QueryCallback_Failure(qcallback, error_code, error_message);
}

void ServerConcurrentClient::send_QueryCallback_Failure(const  ::thrift_codegen::RObject& qcallback, const int32_t error_code, const std::string& error_message)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("QueryCallback_Failure", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_QueryCallback_Failure_pargs args;
  args.qcallback = &qcallback;
  args.error_code = &error_code;
  args.error_message = &error_message;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::SchemeHandlerFactory_Register(const std::string& schemeName, const std::string& domainName, const  ::thrift_codegen::RObject& schemeHandlerFactory)
{
  send_SchemeHandlerFactory_Register(schemeName, domainName, schemeHandlerFactory);
}

void ServerConcurrentClient::send_SchemeHandlerFactory_Register(const std::string& schemeName, const std::string& domainName, const  ::thrift_codegen::RObject& schemeHandlerFactory)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("SchemeHandlerFactory_Register", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_SchemeHandlerFactory_Register_pargs args;
  args.schemeName = &schemeName;
  args.domainName = &domainName;
  args.schemeHandlerFactory = &schemeHandlerFactory;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::ClearAllSchemeHandlerFactories()
{
  send_ClearAllSchemeHandlerFactories();
}

void ServerConcurrentClient::send_ClearAllSchemeHandlerFactories()
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("ClearAllSchemeHandlerFactories", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_ClearAllSchemeHandlerFactories_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::RequestContext_ClearCertificateExceptions(const int32_t bid, const  ::thrift_codegen::RObject& completionCallback)
{
  send_RequestContext_ClearCertificateExceptions(bid, completionCallback);
}

void ServerConcurrentClient::send_RequestContext_ClearCertificateExceptions(const int32_t bid, const  ::thrift_codegen::RObject& completionCallback)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("RequestContext_ClearCertificateExceptions", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_RequestContext_ClearCertificateExceptions_pargs args;
  args.bid = &bid;
  args.completionCallback = &completionCallback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::RequestContext_CloseAllConnections(const int32_t bid, const  ::thrift_codegen::RObject& completionCallback)
{
  send_RequestContext_CloseAllConnections(bid, completionCallback);
}

void ServerConcurrentClient::send_RequestContext_CloseAllConnections(const int32_t bid, const  ::thrift_codegen::RObject& completionCallback)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("RequestContext_CloseAllConnections", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_RequestContext_CloseAllConnections_pargs args;
  args.bid = &bid;
  args.completionCallback = &completionCallback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::CookieManager_Create( ::thrift_codegen::RObject& _return)
{
  int32_t seqid = send_CookieManager_Create();
  recv_CookieManager_Create(_return, seqid);
}

int32_t ServerConcurrentClient::send_CookieManager_Create()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("CookieManager_Create", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_CookieManager_Create_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_CookieManager_Create( ::thrift_codegen::RObject& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("CookieManager_Create") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_CookieManager_Create_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "CookieManager_Create failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::CookieManager_Dispose(const  ::thrift_codegen::RObject& cookieManager)
{
  send_CookieManager_Dispose(cookieManager);
}

void ServerConcurrentClient::send_CookieManager_Dispose(const  ::thrift_codegen::RObject& cookieManager)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("CookieManager_Dispose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_CookieManager_Dispose_pargs args;
  args.cookieManager = &cookieManager;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

bool ServerConcurrentClient::CookieManager_VisitAllCookies(const  ::thrift_codegen::RObject& cookieManager, const  ::thrift_codegen::RObject& visitor)
{
  int32_t seqid = send_CookieManager_VisitAllCookies(cookieManager, visitor);
  return recv_CookieManager_VisitAllCookies(seqid);
}

int32_t ServerConcurrentClient::send_CookieManager_VisitAllCookies(const  ::thrift_codegen::RObject& cookieManager, const  ::thrift_codegen::RObject& visitor)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("CookieManager_VisitAllCookies", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_CookieManager_VisitAllCookies_pargs args;
  args.cookieManager = &cookieManager;
  args.visitor = &visitor;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool ServerConcurrentClient::recv_CookieManager_VisitAllCookies(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("CookieManager_VisitAllCookies") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      Server_CookieManager_VisitAllCookies_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "CookieManager_VisitAllCookies failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

bool ServerConcurrentClient::CookieManager_VisitUrlCookies(const  ::thrift_codegen::RObject& cookieManager, const  ::thrift_codegen::RObject& visitor, const std::string& url, const bool includeHttpOnly)
{
  int32_t seqid = send_CookieManager_VisitUrlCookies(cookieManager, visitor, url, includeHttpOnly);
  return recv_CookieManager_VisitUrlCookies(seqid);
}

int32_t ServerConcurrentClient::send_CookieManager_VisitUrlCookies(const  ::thrift_codegen::RObject& cookieManager, const  ::thrift_codegen::RObject& visitor, const std::string& url, const bool includeHttpOnly)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("CookieManager_VisitUrlCookies", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_CookieManager_VisitUrlCookies_pargs args;
  args.cookieManager = &cookieManager;
  args.visitor = &visitor;
  args.url = &url;
  args.includeHttpOnly = &includeHttpOnly;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool ServerConcurrentClient::recv_CookieManager_VisitUrlCookies(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("CookieManager_VisitUrlCookies") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      Server_CookieManager_VisitUrlCookies_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "CookieManager_VisitUrlCookies failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

bool ServerConcurrentClient::CookieManager_SetCookie(const  ::thrift_codegen::RObject& cookieManager, const std::string& url, const  ::thrift_codegen::Cookie& cookie)
{
  int32_t seqid = send_CookieManager_SetCookie(cookieManager, url, cookie);
  return recv_CookieManager_SetCookie(seqid);
}

int32_t ServerConcurrentClient::send_CookieManager_SetCookie(const  ::thrift_codegen::RObject& cookieManager, const std::string& url, const  ::thrift_codegen::Cookie& cookie)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("CookieManager_SetCookie", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_CookieManager_SetCookie_pargs args;
  args.cookieManager = &cookieManager;
  args.url = &url;
  args.cookie = &cookie;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool ServerConcurrentClient::recv_CookieManager_SetCookie(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("CookieManager_SetCookie") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      Server_CookieManager_SetCookie_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "CookieManager_SetCookie failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

bool ServerConcurrentClient::CookieManager_DeleteCookies(const  ::thrift_codegen::RObject& cookieManager, const std::string& url, const std::string& cookieName)
{
  int32_t seqid = send_CookieManager_DeleteCookies(cookieManager, url, cookieName);
  return recv_CookieManager_DeleteCookies(seqid);
}

int32_t ServerConcurrentClient::send_CookieManager_DeleteCookies(const  ::thrift_codegen::RObject& cookieManager, const std::string& url, const std::string& cookieName)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("CookieManager_DeleteCookies", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_CookieManager_DeleteCookies_pargs args;
  args.cookieManager = &cookieManager;
  args.url = &url;
  args.cookieName = &cookieName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool ServerConcurrentClient::recv_CookieManager_DeleteCookies(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("CookieManager_DeleteCookies") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      Server_CookieManager_DeleteCookies_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "CookieManager_DeleteCookies failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

bool ServerConcurrentClient::CookieManager_FlushStore(const  ::thrift_codegen::RObject& cookieManager, const  ::thrift_codegen::RObject& completionCallback)
{
  int32_t seqid = send_CookieManager_FlushStore(cookieManager, completionCallback);
  return recv_CookieManager_FlushStore(seqid);
}

int32_t ServerConcurrentClient::send_CookieManager_FlushStore(const  ::thrift_codegen::RObject& cookieManager, const  ::thrift_codegen::RObject& completionCallback)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("CookieManager_FlushStore", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_CookieManager_FlushStore_pargs args;
  args.cookieManager = &cookieManager;
  args.completionCallback = &completionCallback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool ServerConcurrentClient::recv_CookieManager_FlushStore(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("CookieManager_FlushStore") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      Server_CookieManager_FlushStore_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "CookieManager_FlushStore failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

} // namespace

